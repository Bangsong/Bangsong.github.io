<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring的IOC容器之基于注解的配置]]></title>
    <url>%2FBlog%2Funcategorized%2FSpring%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring的IOC容器之基于XML的配置]]></title>
    <url>%2FBlog%2Funcategorized%2FSpring%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库迁移]]></title>
    <url>%2FBlog%2FOralce%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[创建用户 创建表空间 查看要迁移用户的表空间：select username,default_tablespace from user_users;（查询当前用户表空间） 查看当前表空间文件位置：SELECT * FROM Dba_Data_Files ddf WHERE ddf.tablespace_name = &#39;tableSpace&#39; 切换PDB：alter session set container=PDBORCL（若为oracle12则需要此步骤） 创建表空间： 1234create tablespace 表空间datafile '表空间文件' size 300m autoextend on next 100m; 创建用户12create user 用户名 identified by 密码default tablespace 表空间; 授权1234567891011121314151617181920grant connect to 用户名;grant resource to 用户名;grant CREATE PUBLIC DATABASE LINK,DROP PUBLIC DATABASE LINK to 用户名;grant CREATE DATABASE LINK to 用户名; grant CREATE ANY TYPE to 用户名;grant connect to 用户名;grant alter any index to 用户名;grant alter any table to 用户名;grant alter any trigger to 用户名;grant alter any sequence to 用户名;grant create any index to 用户名;grant create any job to 用户名;grant create any view to 用户名;grant create any trigger to 用户名;grant create procedure to 用户名;grant create table to 用户名;grant create any sequence to 用户名;grant create any view to 用户名;grant DEBUG CONNECT SESSION to 用户名;grant unlimited tablespace to 用户名; 设置pdb用户TNS将SERVICE_NAME设置为pdborcl，正常的是orcl 123456789PDBORCL = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = pdborcl) ) ) 正常用户的TNS 12345678ORCL = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) ) 登录用户​ 使用之前创建用户的账号密码选择pdboracl，点击登录。 可能会用到的命令： 删除表空间及表空间文件：drop tablespace 表空间 including contents and datafiles cascade constraint; 切换PDBORCL：alter session set container=PDBORCL; 切换CDB：alter session set container=CDB$ROOT; 导出数据 导出数据不导出表数据 1exp username/pwd file=导出数据文件 owner=username rows=false 导入数据1imp 新用户/pwd@*** fromuser=原来用户 touser=新用户 file=*:\***.dmp buffer=10240000 这个命令导出，如果导出 导入的用户不一致就要加上 fromuser touser 的参数，如果一致，这两个参数可以不加。 通过plsql导出用户对象​ 登录需要导出的用户，选择如下： ​ 选择导出的数据： 其中，若导出和导入的用户相同，则直接默认就好了，然后设置一下Output file，点击Export就行了。若导出和导入用户不相同，则勾掉Include Owner。 导入用户对象​ 登录要导入的用户，将导出的sql文件拖入然后执行就行了。导入完成后要注意有没有报错，报错的话自行手动修改。]]></content>
      <categories>
        <category>Oralce数据库</category>
      </categories>
      <tags>
        <tag>Oralce数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle数据库安装]]></title>
    <url>%2FBlog%2FOralce%E6%95%B0%E6%8D%AE%E5%BA%93%2Foracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[下载​ 在oracle官网下载页面，选择下载的版本，点击下载(下载需要登录)。 ​ 附上两个版本的百度云链接： oracle11gR2_1of2(x64)（密码：bfbu）,oracle11gR2_2of2（密码：5w9h）， oracle12g(x64)，密码：3lbo 安装解压文件​ 将下载下来的两个文件（oracle11g是两个，oracle12g是一个）同时选中解压到一个文件夹下，解压好之后进入解压的文件夹database，点击setup ​ 配置安全更新​ 勾掉接受安全更新，点击”下一步”，提示”未提供电子邮件地址”，点击”是”。 ​ 安装选项​ 选择第一个选项创建和配置数据库，点击下一步。 ​ 选择系统类​ 根据个人需求选择类型，第一个是桌面类，第二个是服务器类，我选择的是服务器类，点击下一步。 选择数据库安装选项​ 根据需要选择，一般选择第一个选项单实例数据库安装，点击下一步。 选择安装类型​ 这里选择高级安装。 选择数据库版本​ 选择第一个企业版，点击下一步。 指定oracle主目录用户​ 默认就好，点击下一步。 指定安装位置​ 自行选择安装位置。 选择配置类型默认就好一般用途/事务处理。 指定数据库标识符​ 这里我安装的是oracle12g，所以下面会有一个创建为容器数据库的，这个是oracle12g新特性可插拔数据库。若你安装的是oracle11g则不会看到此选项，若是oracle12g，默认就好了。 指定配置选项(非常重要)​ 指定配置选项中，有一个字符集选项，这个非常重要、非常重要、非常重要!!!为什么要强调这个呢，嗯…你吃过亏就知道了，心里的苦说不出。 ​ 若你要迁移数据库的话，一定要看要迁移的数据库的字符集是什么，一般的都会设置SIMPLIFIED CHINESE_CHINA.ZHS16GBK。 注意看三个选项： 使用Unicode：这个使用的是SIMPLIFIED CHINESE_CHINA.AL32UTF8，若你使用这个字符集，则选择。 使用操作系统字符集：注意：这里是使用和操作系统相同的字符集，一般用这个就行，但是有时候服务器的操作系统是全英文的，字符集不一定是ZHS16GBK，所以一定要看后面括号里面的是不是你要选择的字符集。 从以下字符集列表中选择：若以上两种都不是你想要的，则在此选项中找到你想要的字符集就行了。 点击下一步。 ​ 指定数据库存储选择​ 默认就好。 指定管理选项​ 默认就好。 指定恢复选项​ 默认就好。 指定方案口令​ 这里是指定数据库管理员密码的，可以使用第一个为每个管理员设置不同的密码，也可使用第二个为所有管理员设置统一密码。提示密码不符合建议，点击是就行了。 先决条件检查 安装​ 点击安装。 若你在做数据库迁移的事情，可能会出现字符集不对的问题，可以自行百度修改，也可以直接写在oracle实例，重新安装实例。 卸载oracle实例​ 打开cmd,输入：dbca，选择delete database ​ 查看数据库字符集：select * from nls_database_parameters; 中文乱码问题​ 若服务器的操作系统是英文版的，你用plsql打开查询数据发现依旧是乱码，这个时候是因为操作系统没有中文安装包。 ​ 百度云链接：windows server 2012R2操作系统的中文安装包，密码：y904 ​ 下载好安装包之后，win+R运行lpksetup。点击Install display langues。 ​ ​ 然后点击Browse...将下载的文件选中，点击next，等待安装完成。 ​ ​ 设置中文，安装如下操作。 设置之后需要重新登录，这时会提示是否注销，点击log off now。 结语​ 以上就是oracle数据库的安装过程，是为了记录一下，方便以后在做相关事情的时候查阅，希望也可以帮助正在寻找帮助的你。]]></content>
      <categories>
        <category>Oralce数据库</category>
      </categories>
      <tags>
        <tag>Oralce数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot之HelloWorld]]></title>
    <url>%2FBlog%2FsprintBoot%2FspringBoot%E4%B9%8BHelloWorld%2F</url>
    <content type="text"><![CDATA[前期准备使用的工具： IntelliJ IDEA2018.2.3 JDK10.0.2 mysql8.0.11 IntelliJ IDEA下载激活相关文章：Idea2018最新永久激活方法 JDK下载地址：https://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html mysql社区版下载地址：https://dev.mysql.com/downloads/mysql/ 工具下载好之后，自行百度配置。 创建springboot项目新建项目 选择spring Initializr 我看网上很多都是用https://start.spring.io/ 这个网址创建项目下载导入的，idea中的spring Initializr和网址创建的是一样的而且少去了下载导入步骤。继续接着创建。 点击next，需要修改就修改，不需要修改就默认，上面的图片中的描述不一定对，建议自行百度了解一下。不过一般不用改的，直接默认就好。 点击next，选择依赖，需要勾选如下依赖，其中，Web是web所需要的依赖，Thymeleaf是模板用于前端页面的。这次只是整合web所以不用导入其他依赖。 点击next，这一步一般可以设置一下项目存放目录，然后点击finish，注意：若你指定的目录不存在，会提示你是否创建，点击ok即可。 若没有当前指定的目录，则提示是否创建，点击ok 创建完之后，目录结构如下： 其中： DemoApplication ：springboot的启动类，代码如下 123456789101112package com.example.demo; import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; static：存放静态资源文件 ​ 静态资源访问默认会去resources/webjars/，但是你会发现目录中没有webjars。其实webjars是以jar包的方式引入静态资源。webjars官网上有对应的maven引用。 ​ 若webjars下没有，则按照以下排序依次去找： 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;,&quot;/&quot;：当前项目的根路径 templates：存放模板文件 application.properties：配置文件 test：单元测试 pom文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;10&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 默认请求根路径地址，会查找templates下的index.html，若不配置我们启动项目看看，会发现404。 接下来，我们在templates下创建一个index.html。 然后重新启动，并刷新看一下。 或者，可以创建一个控制器，在控制器中指定请求返回的页面。创建一个homeController，并且新建一个页面hello。 重启项目，查看： 结语​ 这就是最基本的springboot项目了，只整合了web。]]></content>
      <categories>
        <category>sprintBoot</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建属于自己的博客之添加评论功能]]></title>
    <url>%2FBlog%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[我昨晚耗费了几个小时，终于设置添加好了评论功能。我试了两个评论系统，最终选择了gitlak。 添加valine评论注册Leancloud 在Leancloud注册一个账号，名字随意 创建一个应用 然后应用→设置→应用key，拿到自己的appid和appkey。 ​ 配置valine​ 在主题配置文件(hexo\blog\themes\next\_config.yml)中搜索valine，将其换成如下代码(注意替换appid和appkey) 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: false appid: appid appkey: appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 疑问或建议，请留言.若需要帮助，请附上联系方式. avatar: mm # gravatar style guest_info: nick,mail # custom comment header pageSize: 10 # pagination size 设置Web安全域名​ 应用→设置→安全中心，找到Web安全域名，将域名放进去。 ​ 添加邮箱通知​ Valine Admin是valine的扩展应用，详情可看配置文档。可根据valineAdmin文档来配置，我就不描述了。 添加gitalk创建OAuth App​ 详情请移步官方文档。 设置OAuth App 注意：Homepage URL后面不要带/，设置页面有Client ID和Client Secret，这两个在配置时需要用到。 配置gittalk修改配置文件​ 首先在主题配置文件(hexo\blog\themes\next\_config.yml)中添加代码： 12345678gitalk: enable: true githubID: github帐号 repo: 仓库名称 # 用于存评论的仓库，若用的主目录则就用：github账号.github.io ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true ​ 博客评论我新建了一个仓库gitTalk，所以repo为gitTalk。我的配置： 12345678gitalk: enable: true githubID: Bangsong repo: gitTalk ClientID: ClientSecret: adminUser: Bangsong #指定可初始化评论账户 distractionFreeMode: true 下载所需文件 在hexo\blog\themes\next\source\lib目录下创建gitalk目录和md5目录 下载gitalk.css。点击下载，将网页中的代码复制保存到gitalk目录为gitalk.css(编码设置为UTF-8) 下载gitalk.min.js。点击下载，将网页中的代码复制保存到gitalk目录为gitalk.min.js(编码设置为UTF-8) 下载md5.min.js。此文件是解决文件名过长导致初始化失败。点击下载，将代码保存在为md5.min.js。(编码设置为UTF-8)。 创建gitalk.swig​ 在hexo\blog\themes\next\layout\_third-party\comments创建gitalk.swig文件，并添加代码： 1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;/Blog/lib/gitalk/gitalk.css&quot;&gt; &lt;script src=&quot;/Blog/lib/gitalk/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/Blog/lib/md5/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: md5(location.pathname), distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 注意： 一定要按照上面的目录放置文件，我在gitalk.swig文件中引用的是本地文件，若按照上面的创建请自行修改引用。 我的github pages是放到Blog文件夹下，所以我在引用前面加了/Blog，若你的是放到根目录，请去掉。 id后面是md5(location.pathname)，这个是通过md5加密防止文件名过长导致初始化失败。 若想引用网络资源，我列一下网络链接 gitalk.css gitalk.min.js md5无法引用网络资源 修改comments.swig​ 修改hexo\blog\themes\next\layout\_third-party\comments\index.swig，添加代码： 1&#123;% include &apos;gitalk.swig&apos; %&#125; 创建gitalk.styl​ 在hexo\blog\themes\next\source\css\_common\components\third-party中添加gitalk.styl文件，并添加代码： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 修改third-party.styl​ 修改hexo\blog\themes\next\css\_common\components\third-party\third-party.styl，添加代码： 1@import "gitalk"; 结语​ 最后，重新生成发布就行了。需要注意的是每一篇文章第一次都需要你手动点击登录初始化一个issues，否则就会出现下面的结果。 ​ 另外附上一些配置gitalk错误的讨论链接点击查看，希望对你有所帮助。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章：函数]]></title>
    <url>%2FBlog%2FLisp%2FCommon%20Lisp%E8%AF%91%E6%9C%AC%E7%AC%94%E8%AE%B04%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[所有的lisp程序的最基本的组成：函数、变量、宏。函数用宏defun定义格式：(defun 函数名 (形参列表) 函数体)如：(defun say (str) (format t “~A” str))约定： 一般类型转换的函数会在名字中使用→ 将一个字符串转为微件(widget)的函数会叫做string-&gt;widget 函数名中的连接符不是下划线，而是横线。 在函数中紧跟这个形参列表之后的字符串可作为描述函数用途的文档字符串。可通过函数documentation获取。函数将最后一个表达式的值作为整个函数的返回值。也可用return-from在函数任何位置立即返回。函数形参列表必要参数：不用关键字修饰的形参，一般为必要参数。当函数调用时，必须为其提供一个实参，每个形参绑定对应的实参。若实参个数过多或过少，则会报错。可选参数：形参前用关键字&amp;optional修饰。在所有必要形参都被赋值之后，若还有剩余实参，则被赋给可选形参。若未被赋值的可选形参会自动绑定值nil。可设置默认值，用列表表示。如：(b 10)。若可选形参未传值，则使用默认值。若检测是否使用默认值，可用形参名加-supplied-p后缀来判断。如：(b 10 b-supplied-p)。当使用默认值为nil，不使用默认值为T 函数形参列表 必要参数：不用关键字修饰的形参，一般为必要参数。当函数调用时，必须为其提供一个实参，每个形参绑定对应的实参。若实参个数过多或过少，则会报错。 可选参数：形参前用关键字&amp;optional修饰。在所有必要形参都被赋值之后，若还有剩余实参，则被赋给可选形参。若未被赋值的可选形参会自动绑定值nil。可设置默认值，用列表表示。如：(b 10)。若可选形参未传值，则使用默认值。若检测是否使用默认值，可用形参名加-supplied-p后缀来判断。如：(b 10 b-supplied-p)。当使用默认值为nil，不使用默认值为T例子: 12(defun test (a &amp;optional (b 10 b-supplied-p)) (format t &quot;a: ~A b: ~A flag: ~A&quot; a b b-supplied-p)) 测试代码： 123456CL-USER&gt; (test 2)a: 2 b: 10 flag: NILNILCL-USER&gt; (test 2 4)a: 2 b: 4 flag: TNIL 剩余参数：形参前用关键字&amp;rest修饰。若当实参个数满足必要形参和可选形参时，剩余实参会被放进一个列表作为剩余形参的值。 例子： 12(defun test (a &amp;optional b &amp;rest values) (format t &quot;a: ~A b: ~A values: ~A&quot; a b values)) 测试代码： 123CL-USER&gt; (test 1 2 3 4 5 6)a: 1 b: 2 values: (3 4 5 6)NIL 关键字参数：形参前用关键字&amp;key修饰。在函数调用时可用:形参名(即关键字)来给特定的形参赋值。此形参也可设置默认值及判断是否使用默认值。用法和可选参数相同。还可以通过列表设置关键字别名，在函数调用时，只能通过别名来赋值。如：((:app a)) 例子： 12(defun test (a &amp;key ((:bp b)) ((:cp c) 3 c-supplied-p) ) (format t &quot;a: ~A b: ~A c: ~A c-flag: ~A&quot; a b c c-supplied-p)) 测试代码： 123456789CL-USER&gt; (test 1 :bp 2)a: 1 b: 2 c: 3 c-flag: NILNILCL-USER&gt; (test 1 :cp 4)a: 1 b: NIL c: 4 c-flag: TNILCL-USER&gt; (test 1 :cp 3)a: 1 b: NIL c: 3 c-flag: TNIL 混合使用不同形参类型混合使用不同形参类型时的声明顺序：必要参数、可选参数、剩余参数、关键字参数。一般组合使用的情况：必要参数和其他的一种类型组合使用。 关键字参数和剩余参数、可选参数组合使用时会出现奇怪的行为，应避免一起使用。(若未给可选参数提供值，则会将关键字参数的关键字和值作为可选参数。) 也有可以组合使用的例子，但暂时先不考虑。 可选参数仅适用于一些较为分散且不确定调用者会提供值的形参。剩余参数适用于接收可变数量的实参。关键字参数适用于给指定参数赋值。 函数返回值函数默认会将最后一个表达式的值作为整个函数的返回值。 可使用return-from使函数在特定位置返回。第一个参数为在返回函数中的函数名，第二个参数为返回值。 作为数据的函数–高阶函数一般使用函数名来调用函数，若将函数看成数据则可将函数作为参数传给另一个函数。 在lisp中，函数是另一种类型的对象。用defun定义一个函数时，创建一个新的函数对象及赋予其一个名字。使用特殊操作符function可获取一个函数的函数对象。接收一个参数并返回参数同名的函数对象。functiong的语法糖为：#&#39; 通过函数对象调用函数的两个函数：funcall和applyfuncall：用于知道传递给函数的实参个数。第一个参数为：被调用的函数对象，其余的参数为传入函数的参数。apply：第一个参数是被调用的函数对象。第二个参数是一个列表，将传入被调函数的参数放到一个列表中。funcall和apply的区别：funcall应用到被调函数上的参数为单一参数，而apply则将一个列表作为应用参数。 例子： 1234(defun test-fun (fn) (funcall fn 1 2 3))(defun test-app (fn) (apply fn &apos;(1 2 3))) 测试代码： 12345CL-USER&gt; (test-fun #&apos;+) 6CL-USER&gt; (test-app #&apos;+)6 匿名函数使用lambda表达式可创建一个匿名函数。第一个参数是形参列表，第二个参数是函数体格式：(lambda (形参列表) 函数体)lambda表达式重要用途是制作闭包，即捕捉了其创建时环境信息的函数。 例子： 12(defun test (x y) (lambda (x y) (+ x y)) x y) 测试代码： 123CL-USER&gt; (test 1 2) 2]]></content>
      <categories>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章：语法和语义]]></title>
    <url>%2FBlog%2FLisp%2FCommon%20Lisp%E8%AF%91%E6%9C%AC%E7%AC%94%E8%AE%B03%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[大多数编程语言，语言的处理器(无论是解释器或编译器)的操作方式都类似黑箱操作。在黑箱内部，语言的处理器通常分成子系统。一个典型的任务划分思路：将处理器分为三个阶段，每个阶段为下一个阶段提供内容。 一个词法分析器将字符流分拆成语元并将其送进一个解析器 解析器再根据该语言的语法在程序中构建一个表达式的树形表示。这棵树被称为抽象语法树。 随即被送进一个求值器，求值器要么直接解释它，要么将其编译成魔种其他语言(如：机器码)。 Common lisp定义了两个黑箱：读取器、求值器 读取器：将文本转为lisp对象。 求值器：用这些对象实现语言的语义。 每个黑箱都定义了一个语法层面。读取器定义了字符串如何被转换为S-表达式的lisp对象。S-表达式适用于由任意对象及其他列表所组成的列表，因此S-表达式可用来表达任意树形表达式。求值器随后定义了一种构建在S-表达式之上的lisp形式的语法。 此种黑箱划分带来的后果： 可将S-表达式用作一种可暴露的数据格式来表达源代码之外的数据。 由于语言的语义是用对象树而非字符串定义而成的，则可通过语言本身来生成代码，则可通过处理现有的数据生成代码，从而达到“可编程的编程语言”的效果，即lisp宏的本意。 S-表达式S-表达式的基本元素是列表、原子。列表由括号所包围，并可包含任何数量的由空格所分隔的元素。原子是所有其他内容。 原子：数字、字符串、名字。 数字：任何数位的序列都会被读取为一个数字。可为整数、比值、小数、科学计数法 字符串：用双引号包含的都是字符串。用反斜杠进行转义。 字符：用#\表示，如：#\a表示字符a 名字：由称为符号的对象表示。如：format、hello-world、db 十个字符不能出现在名字中：开括号、闭括号、双引号、单引号、反引号、逗号、冒号、分好、反斜杠、竖线。如真想用的，则需要用反斜杠转义或将含有需要转义的字符名字用竖线包起来。 读取器将名字转化为符号对象的方式： 当读取名字时，读取器将所有名字中未转义的字符都转为大写。 为了确保同一个文本名字总是被读取成相同的符号，读取器保留这个符号之后，在一个称为包的表汇总查询带有相同名字的已有符号，若找不到，则创建一个新的符号并添加到表中。否则返回那个符号。 名字的约定： 全局变量：开始和结尾用。如：db* 常量：开始和结尾用+。如：+zero+ lisp求值方式：将求值器看做一个函数，接收一个句法良好定义的lisp形式作为参数并返回一个值。 原子可被分为两个类别：符号和所有其他内容。符号在作为lisp形式被求值时会被看作一个变量名，并会被求值为该变量的当前值。所有原子都是自求值对象。 lisp中的真假值为：T和NIL其中NIL既是原子也是列表，nil是空列表。另一类自求值符号是关键字符号(以冒号开始的符号)，当读取器保留这样一个名字时，会自动定义一个以此命名的常量变量并以该符号作为其值。 函数调用函数调用规则：除第一个以外，所有的列表元素它们自身必须是一个形态良好的lisp形式。调用格式：(函数名 参数列表) 函数的所有参数都在函数被调用之前求值。 特殊操作符如：ifif规则：对第一个表达式求值，为非nil则执行第二个表达式，否则执行第三个表达式。quote规则：接收一个参数，并不求值返回。即：将参数不经处理直接返回。语法糖为：’(单引号) 宏宏是一个以S-表达式为其参数的函数，并返回一个lisp形式然后对其求值并用改制取代宏形式。 宏形式的求值过程： 首先宏形式的元素不经求值即被传递到宏函数里 其次，由宏函数所返回的形式(展开式)按照正常的求值规则进行求值。即宏的求值一般为两个阶段：宏展开阶段、展开式求值阶段。 真、假、等价符号nil是唯一的一个假值。其他所有的都是真值。符号T是标准的真值。等价 eq：用来测试“对象标识”，只有当两个对象相同时，才等价。如：相同值的数字和字符用eq比较是不等价的。 eql：与eq相似，可保证当相同类型的两个对象标识相同的数字或字符值时，才等价。 equal：具有相同内容，就等价。 equalp：在比较字符串时忽略大小写。 格式化代码​ 保持美观的代码风格，可方便查找错误及阅读代码。]]></content>
      <categories>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章：简单的数据库实现(源码)]]></title>
    <url>%2FBlog%2FLisp%2FCommon%20Lisp%E8%AF%91%E6%9C%AC%E7%AC%94%E8%AE%B02%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0(%E6%BA%90%E7%A0%81)%2F</url>
    <content type="text"><![CDATA[第二章是一个简单的数据库例子，通过编写一个cd信息的操作，来讲述知识点。 主要设置的知识点： 全局变量 格式化输出 列表的使用 文件的读写 宏 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566;;定义一个全局变量，用于存放数据(defvar *db* nil) ;;制作一个CD需要的信息(defun make-cd (title artist rating ripped) (list :title title :artist artist :rating rating :ripped ripped)) ;;将一条CD信息记录到全局变量中(defun add-record (cd) (push cd *db*)) ;;格式化输出数据(defun dump-db () (format t &quot;~&#123;~&#123;~A: ~10t~A~%~&#125;~%~&#125;&quot; *db*)) ;;交互信息(defun prompt-read (prompt) (format *query-io* &quot;~A: &quot; prompt) (force-output *query-io*) (read-line *query-io*)) ;;交互获取CD信息(defun prompt-for-cd () (make-cd (prompt-read &quot;Title&quot;) (prompt-read &quot;Artist&quot;) (or (parse-integer (prompt-read &quot;Rating&quot;) :junk-allowed t) 0) (y-or-n-p &quot;Ripped [y/n]: &quot;))) ;;添加任意个CD信息(defun add-cds () (loop (add-record (prompt-for-cd)) (if (not (y-or-n-p &quot;Another? [y/n]: &quot;)) (return)))) ;;将所有CD信息保存到文件中(defun save-db (filename) (with-open-file (out filename :direction :output :if-exists :supersede) (with-standard-io-syntax (print *db* out)))) ;;加载文件中的CD信息(defun load-db (filename) (with-open-file (in filename) (with-standard-io-syntax (setf *db* (read in)))));;通用查询(defun select (selector-fn) (remove-if-not selector-fn *db*)) ;;根据artist查询(defun artist-selector (artist) #&apos;(lambda (cd) (equal (getf cd :artist) artist)));;比较根据键比较值(defun make-comparison-expr (field value) `(equal (getf cd ,field) ,value));;循环比较(defun make-comparisons-list (fields) (loop while fields collecting (make-comparison-expr (pop fields) (pop fields))));;定义一个where宏(defmacro where (&amp;rest clauses) `#&apos;(lambda (cd) (and ,@(make-comparisons-list clauses))));;删除函数(defun delete-rows (selector-fn) (setf *db* (remove-if selector-fn *db*))) 在eamcs中使用C-x C-f新建一个文件，输入文件名之后回车。 将上述源代码粘贴复制到此文件中，使用C-x C-s保存文件。 保存完成之后，在emacs中使用M-x输入slime回车，启动REPL(lisp环境)。 在REPL中输入：(load “CD.lisp”)回车，加载保存的文件。 到这一步，则可使用上述源码中的所有函数，接下来进行测试。 测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546CL-USER&gt; *db*NILCL-USER&gt; (add-cds)Title: BangBomArtist: AreRating: 5 Ripped [y/n]: (y or n) y Another? [y/n]: (y or n) yTitle: So happyArtist: BreRating: 8 Ripped [y/n]: (y or n) n Another? [y/n]: (y or n) n NILCL-USER&gt; (dump-db)TITLE: So happyARTIST: BreRATING: 8RIPPED: NIL TITLE: BangBomARTIST: AreRATING: 5RIPPED: T NILCL-USER&gt; (save-db &quot;CD.db&quot;)((:TITLE &quot;So happy&quot; :ARTIST &quot;Bre&quot; :RATING 8 :RIPPED NIL) (:TITLE &quot;BangBom&quot; :ARTIST &quot;Are&quot; :RATING 5 :RIPPED T))CL-USER&gt; (select (where :title &quot;BangBom&quot;))((:TITLE &quot;BangBom&quot; :ARTIST &quot;Are&quot; :RATING 5 :RIPPED T))CL-USER&gt; (select (where :artist &quot;Bre&quot;))((:TITLE &quot;So happy&quot; :ARTIST &quot;Bre&quot; :RATING 8 :RIPPED NIL))CL-USER&gt;]]></content>
      <categories>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章：REPL简介]]></title>
    <url>%2FBlog%2FLisp%2FCommon%20Lisp%E8%AF%91%E6%9C%AC%E7%AC%94%E8%AE%B01%E4%B9%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%20REPL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[common lisp源文件扩展名一般为.lisp或.cl emacs命令：C-c C-q调用：slime-close-parens-at-point。将插入必要数量的闭括号以匹配当前的所有开括号。 emacs命令：C-c C-c可以编译光标所在的当前lisp代码 emacs命令：C-c C-z可以回到REPL(lisp编译环境) emacs命令：在REPL中输入逗号，则在emacs底部输入quit或sayoonara，回车即可退出REPL。 emacs命令：从调试器中退出：q 在REPL中使用load可加载lisp文件。加载完成之后则文件中的代码就被编译了。如：(load “test.lisp”) 加载文件中有用定义的方法：先用compile-file编译，然后再用load加载编译后产生的文件，即FASL文件(快速加载文件)如：(load (compile-file “test.lisp”)) eamcs命令：C-c C-l调用slime-load-file。加载文件emacs命令：C-c C-k可以编译并加载那个当前缓冲区所关联的文件]]></content>
      <categories>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Lisp环境搭建]]></title>
    <url>%2FBlog%2FLisp%2FWindows%E4%B8%8BLisp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前期准备工具： Emacs：Emacs下载地址，附上emacs26百度云链接，密码：vme1 SBCL：SBCL下载地址，附上SBCL百度云链接，密码：6qdy Sline：gitHub地址，附上Sline百度云链接，密码：nlml 安装安装Emacs 将下载下来的压缩文件解压，即可，不需要安装。 在windows下，一开始是找不到.emacs配置文件的，需要打开emacs随便更改一下配置，保存一下，才能生成.emacs。 运行emacs，选择Options，这里面随便更改一个配置项，然后选择save options。则会在下面看到保存.emacs文件路径。然后把刚刚改的配置项再改回来，选择save options。 然后去文件夹下找到.emacs文件，这是隐藏文件，一般资源管理器是不显示的，需要勾选“隐藏的项目”。 然后打开文件，将下列配置项填入： 123456(setq inferior-lisp-program "C:/Software/lisp/sbcl_1.4.2/sbcl.exe");设置优先使用哪种Common Lisp实现(add-to-list 'load-path "C:/Software/lisp/slime-master/");设置Slime路径(require 'slime)(slime-setup)(require 'slime-autoloads)(slime-setup '(slime-fancy));让slime变得更好看，比如把sbcl的*变成CL-USER&gt; 保存文件，重启emacs，然后Alt+x，输入slime，即可进入lisp环境。 注意事项 sbcl安装的时候，默认安装就行，安装时会自动设置sbcl环境变量。（有可能需要重启才能生效，可以先不重启，不行的话重启一下试试） emacs配置文件中sbcl 路径中一定要加sbcl.exe emacs配置文件中所有的路径用\或/ 结语​ 以上就是windows下配置Lisp环境，还有其他的工具可以配置，请自行百度。]]></content>
      <categories>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA2018最新永久激活方法]]></title>
    <url>%2FBlog%2FIDEA%2FIDEA2018%E6%9C%80%E6%96%B0%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下载IDEA​ 在IDEA官网下载最新的IDEA，自行选择版本。 下载破解补丁​ 去lanyus网址下载破解补丁。我百度云也保存了一份，可点击百度云链接，密码：ww13。 修改host​ 修改在C:\Windows\System32\drivers\etc目录下的host，在文件中添加：0.0.0.0 account.jetbrains.com ​ 修改后的host文件链接, 密码：ihnm。下载后直接替换。 用补丁代替IDEA的验证​ 找到IDEA的JVM配置文件，一般会在C:\Users\用户名\.IntelliJIdea2018.1\config下的idea64.exe.vmoptions文件 ​ 或者在IDEA中点击Help-&gt; Edit Custom VM Options …自动打开 ​ 在该文件最后添加一句:-javaagent:{你刚刚下载的补丁的路径} ​ 例如:-javaagent:C:/Software/IntelliJ IDEA 2018/JetbrainsCrack-3.1-release-enc.jar ​ 重启IDEA ​ 在激活对话框中选Activation code 随便输入 点击OK ​ 或者打开Idea，在Help→Register...中填写激活码。 自定义激活码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; "licenseId":"ThisCrackLicenseId", "licenseeName":"Bangsong",//名字 "assigneeName":"Bangsong",//名字 "assigneeEmail":"",//邮箱 "licenseRestriction":"Thanks Rover12421 Crack",//激活信息 "checkConcurrentUse":false, "products":[//各个产品的代码以及过期时间 &#123;"code":"II","paidUpTo":"2099-12-31"&#125;, &#123;"code":"DM","paidUpTo":"2099-12-31"&#125;, &#123;"code":"AC","paidUpTo":"2099-12-31"&#125;, &#123;"code":"RS0","paidUpTo":"2099-12-31"&#125;, &#123;"code":"WS","paidUpTo":"2099-12-31"&#125;, &#123;"code":"DPN","paidUpTo":"2099-12-31"&#125;, &#123;"code":"RC","paidUpTo":"2099-12-31"&#125;, &#123;"code":"PS","paidUpTo":"2099-12-31"&#125;, &#123;"code":"DC","paidUpTo":"2099-12-31"&#125;, &#123;"code":"RM","paidUpTo":"2099-12-31"&#125;, &#123;"code":"CL","paidUpTo":"2099-12-31"&#125;, &#123;"code":"PC","paidUpTo":"2099-12-31"&#125;, &#123;"code":"DB","paidUpTo":"2099-12-31"&#125;, &#123;"code":"GO","paidUpTo":"2099-12-31"&#125;, &#123;"code":"RD","paidUpTo":"2099-12-31"&#125; ], "hash":"2911276/0", "gracePeriodDays":7, "autoProlongated":false &#125; 将其复制过去，修改你要修改的信息，点击激活，然后看一下help→about的信息，激活已成功。(注意名字不能为中文，否则会乱码) ​]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建属于自己的博客之博客主题配置二]]></title>
    <url>%2FBlog%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[在博客主题配置一中，已经介绍了网站的基本配置和右侧的配置，接下来继续说一下其他的配置。 顶部加载条显示​ 打开hexo\blog\themes\next\_config.yml搜索pace，设置为true，选择样式 12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash #样式 主页文章边框阴影效果​ 打开themes/next/source/css/_custom/下的custom.styl，添加代码： 1234567.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 修改文章间分割线​ 打开themes/next/source/css/_common/components/post/下的post-eof.styl,修改如下： 123456789.posts-expand &#123; .post-eof &#123; display: block; width: 0%; height: 0px; background: $grey-light; text-align: center; &#125;&#125; 代码块自定义​ 打开themes/next/source/css/_custom/下的custom.styl,添加代码： 1234567891011121314code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 边框的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 博文置顶​ 打开hexo\blog\node_modules/hexo-generator-index/lib/generator.js，将代码全部替换 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（异或操作不行） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; ​ 然后在想置顶的博文头部信息添加top属性，属性值越大越靠前。 12345title: hello worlddate: 2018-9-24 21:41:13tags: '欢迎界面'categories: '欢迎界面'top: 99999 文章顶部显示更新时间​ 打开hexo\blog\themes\next_config.yml搜索updated_at，设置为true 123456# Post meta display settingspost_meta: item_text: true created_at: true updated_at: ture categories: true ​ 在博文头部信息添加updated属性 123456title: hello worlddate: 2018-9-24 21:41:13tags: '欢迎界面'categories: '欢迎界面'top: 99999updated: 2018-9-24 21:41:13 #更新时间 统计功能(显示文字字数，阅读时长)​ 在hexo\blog下，执行cmd命令。 1npm i --save hexo-wordcount ​ 打开hexo\blog\themes\next\_config.yml搜索post_wordcount，将其改为如下设置。 1234567891011# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true #字数统计 wordcount: true #预览时间 min2read: true #总字数,显示在页面底部 totalcount: false separated_meta: true 博文链接样式​ 打开 hexo\blog\themes/next/source/css/_custom/下的custom.styl,添加代码 12345678910.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 文章结束标语​ 在hexo\blog\themes\next\layout\_macro中新建 passage-end-tag.swig 文件,并添加如下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------ END ------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; ​ 打开hexo\blog\themes\next\layout\_macro\post.swig搜索END POST BODY，在其上面添加如下div内容 123456789&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; &#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; ​ 打开hexo\blog\themes\next\_config.yml，在文件最后添加如下代码 123# 文章末尾添加“END”标记passage_end_tag:enabled: true 开启版权声明​ 在_config.yml中搜索post_copyright，设置为true 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 隐藏底部的hexo推荐​ 打开hexo\blog\themes\next\_config.yml搜索footer，设置为false，设置如下 12345678910111213141516171819202122footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: false # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt; 开启博文访问量统计​ 打开hexo\blog\_config.yml搜索busuanzi_count，设置为true 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 阅读次数 page_pv_footer: 结语​ 以上就是next主题的基本配置了，后续有新的配置会再更新改主题的文章。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建属于自己的博客之博客主题配置一]]></title>
    <url>%2FBlog%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本章基础是已经通过hexo在本地初始化好了一个blog，若还未搭建，可以参考我之前的文章：搭建属于自己的博客之环境变量。 本章介绍的主题是Next，更多主题可查看hexo主题，Next官网还在建设中，所以暂时没有什么可以了解的，个人感觉这个主题还不错。 Next主题安装打开cmd，移动到之前创建的博客文件夹hexo\blog下，然后执行命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 下载之后就会在blog\themes中找到next文件夹，其文件夹就是next的所有内容。 然后修改hexo\blog下的_config.yml文件，将其主题改为next主题： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 既然说到_config.yml(当前博客网址的配置文件)，我就说一下这个文件的一些配置吧。 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 theme 主题 上面的是在hexo官网文档摘录的，我只列出了基本需要配置的属性，所有的属性请看官方文档。 注意事项：网址中文乱码解决：将language设置为hexo\blog\themes\next\languages下面所包含的文件名字，即：zh-Hans。然后将_config.yml保存为utf-8编码(可以通过记事本另存为)。设置完成之后重新清楚生成。 附上我的配置文件代码，注意：因为我的github pages上还有其他项目，所以我将url和root改为了/Blog/，若你的github pages上只有你的博客，则去掉即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: XGamersubtitle: 一个人，有一个梦，追寻着...description: 个人博客keywords:author: 万能的小明language: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://bangsong.github.io/Blog/root: /Blog/permalink: :category/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 这一块配置比较简单，请安装上述配置文件自行配置，注意一定要将主题改为next否则下面配置next都将无效. 安装好之后，并将主题更改为next之后，就要开始设置next了。找到hexo\blog\themes\next文件夹下的_config.yml，注意这个是next主题的配置文件，和之前的那个不一样，之前的那个是博客网站的配置文件。 简单列一下配置属性： 参数 描述 favicon 网站图标 footer 网站底部信息 menu 网站菜单 menu_icons 菜单图标是否显示 scheme 主题风格 social 侧边栏的社交链接 links 友情链接 avatar 头像 Next主题设置​ 接下来修改，默认都是next主题的配置文件(hexo\blog\themes\next\_config.yml)，特殊情况会特别提醒。 主题风格设置​ 在_config中搜索Schemes，然后将你想使用的风格签名的#去掉即可，我使用的是Gemini。 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 修改博文访问路径​ 打开hexo\blog\_config.yml搜permalink索，修改如下(若是直接复制我上文的配置文件，则这个设置过了) 1permalink: :category/:title/ 菜单配置​ 在_config中搜索menu，然后设置其下的属性值。其中||前面配置的是菜单项对应的目录，||后面配置的是菜单的图标。 123456789menu: home: / || home #首页 tags: /tags/ || tags #标签 categories: /categories/ || th #分类 archives: /archives/ || archive #归档 #schedule: /schedule/ || calendar #日程表 #sitemap: /sitemap.xml || sitemap #站点地图 #commonweal: /404.html || heartbeat #公益404 about: /about/ || user #关于 菜单图标​ next使用的是 Font Awesome 提供的图标，如需替换自行查看。在_config中搜索menu_icos，将其设置为true可在其下设置对应的菜单图标或新增菜单图标。在上面配置的图标就是引用这个地方(若没有配置，则默认)的配置。 123456789101112menu_icons: enable: true #这下面的默认是没有的，不修改默认图标或者不新增的话，下面是不用添加的。 home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat catalogue: th-list #新增menu_icon 头像设置### 头像图片指定 ​ 在_config中搜索avatar，将值设置为你所要引用图片的地址，或者将本地的头像图片放到themes\next\source\images下，然后将avatar设置为：/images/图片名。 1avatar: /images/user.jpg 头像样式修改(可选)​ 修改themes/next/source/css/_common/components/sidebar/下的sidebar-author.syl文件,修改如下： 1234567891011121314151617181920212223242526272829#头像圆角.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; transition: 2.5s all; &#125;#鼠标悬停时头像旋转.site-author-image:hover &#123; transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 设置社交链接​ 在_config中搜索social，默认有好多社交链接配置，将其修改为自己的社交链接就行。若想显示图标，则social_icons设置为true。 1234567891011social: GitHub: https://github.com/Bangsong || github E-Mail: mailto:btfak@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 设置友情链接​ 在_config中搜索links，简单描述一下配置属性： 参数 描述 links_icon 图标 links_title 文字 links_layout 布局 links 友情链接地址 配置如下： 1234567# Blog rollslinks_icon: linklinks_title: 友情链接links_layout: block#links_layout: inlinelinks: 暂无友链，如需请Email: javascript:void(0); 设置页面浏览进度​ 在_config中搜索scrollpercent，然后将其设置为true，若想将其设置到左侧(默认在右侧)，将b2t设置为true。修改如下： 12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true hexo操作 清除自动生成的静态页面及文件 1hexo clean 自动生成静态页面就文件 1hexo generate 或者 hexo g 启动服务 1hexo service 或者 hexo s ​ 我将清除和生成操作写成了一个脚本：hexoAuto.bat，并将其放到hexo目录下： 1cd blog &amp;&amp; hexo clean &amp;&amp; hexo g ​ 然后将其创建一个快捷键，并放到C:\Users\Administrator目录下，这个目录就是windows+R输入命令的文件夹。 然后每次需要清除生成时，只需windows+R，输入hexoAuto，则会自动执行。其中，&amp;&amp;表示当前命令执行成功之后会继续执行下一条命令。 同理，将自动生成然后提交到github的命令按照这种方式写一个blogUpdate.bat，然后需要提交到github直接windows+R，输入blogUpdate回车即可。不过一键部署是有更简单的方法，我没有配置成功，所以只能按照这种方法了。 blogUpdate.bat 1cd blog &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; xcopy public E:\GitCode\Bangsong.github.io\Blog /y /e &amp;&amp; cd E:\GitCode\Bangsong.github.io\Blog &amp;&amp; git add . &amp;&amp; git commit -m "update" &amp;&amp; git push origin master 其中，xcopy那一步是将生产的静态文件复制到git的本地仓库目录中，然后添加本地仓库、提交、提交到远程仓库。 经过上述配置之后，你可能想开始写文章了。下面就简单介绍一下文章创建等一些操作。 如果你是按照我上面来配置的话，应该没改动默认的文件夹结构，若改动了之后，那应该你就知道每个文件夹所对应的关系，我就不在这陈述了。 通过Hexo创建博文创建文章​ 打开cmd，移动到hexo\blog下，执行文章创建命令： 1hexo new post 文章名 ​ 注意：第三个参数是用来指定文章放置的位置，post是指_post(hexo默认创建的)。若你想新建一个文件夹，则： 1hexo new 目录名 文章名 ​ 上述配置过标签和分类，那么我就以这两个例子来说一下。 创建标签目录​ 执行命令： 1hexo new tags ​ 注意：若不指定文章名则默认会在目录下生成一个index.md文件。tags是上述配置标签的目录。无需写东西，使用默认创建的index.md就行，系统会默认将你的所有的文章按照你文章所标的标签来分类整理。 ​ 若需要将某篇博文放置到某个标签下，则只需在文章的头部信息添加tags信息就行，需要注意的是每个属性和属性值直接都是有一个空格的，如： 123title: hello worlddate: 2018-9-24 21:41:13tags: '欢迎界面' 然后你再次生成运行，点击菜单中的标签就会发现hello world自动归类到了欢迎界面。 ​ 分类菜单也是如此，只需要创建通过命令创建一个目录就行，hexo会自动创建一个index.md，此文件不用修改，要想将某篇博文归为某一类文章则，只需在其头部信息添加categories就行。 1234title: hello worlddate: 2018-9-24 21:41:13tags: '欢迎界面'categories: '欢迎界面' 再次生成运行，点击菜单中的分类就会发现hello world自动归类到了欢迎界面。 创建关于​ 关于界面我配置的是放在about目录下，同样需要创建一个about。 1hexo new about ​ 创建完成之后在index.md中添加相应的信息就行了。 404​ 执行命令 1hexo new 404 ​ 在404\index.md文件中，将头部信息修改一些，将内容修改为相应的404界面，我使用的是腾讯公益，你可以直接复制过去。 123456789101112131415161718192021222324---title: 404date: 2018-09-21 10:22:13comments: falsepermalink: /404---&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt; 配置网站查询​ 在hexo\blog目录下执行命令 1npm install hexo-generator-searchdb --save ​ 打开该目录下的_config.yml添加代码： 12345search: path: search.xml field: post format: html limit: 10000 ​ 打开hexo\blog\themes\next目录下的_config.yml搜索local_search，将其设置为true。 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 ​ 重新生成运行，点击查询即可全局搜索文章了。 结语​ 以上只是配置网站及网站左侧的一些信息。更多配置请关注以后的章节。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建属于自己的博客之环境搭建]]></title>
    <url>%2FBlog%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[环境了解工具： Node npm hexo git 本教程使用的是Hexo + gitHub Pages 搭建的. Hexo：快速生成静态博客的页面. gitHub Pages：充当服务器. Hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 ​ 官方简介：快速、简洁且高效的博客框架。 特点： 速度快 支持markdowm 一键部署 丰富的插件 gitHub​ gitHub是一个面向开源及私有软件项目的托管平台，简单一句：程序员的FaceBook。 环境安装Node安装​ 首先，在Node官网下载最新版的Node，选择LTS版本，下载好后安装。一般默认安装就好，不会的自行百度安装一下吧。 ​ 安装好之后，Ctrl+R输入cmd启动cmd，执行命令查看版本号(若提示不是内外部命令，则设置一下环境变量)： 1node -v npm安装​ npm是Node的包管理工具，可以自动将所下载的包及依赖包一起下载下来。Node已经集成了npm，所以不需要再安装了。 ​ 启动cmd，输入命令查看版本号： 1npm -v Hexo安装​ 所有最好的教程都是官网文档，我们可以去Hexo官网做个入门学习，我介绍一下基本操作。 安装hexo​ 打开cmd，执行命令下载安装hexo 1npm install hexo-cli -g ​ 安装好后，默认安装的目录：C:\Users\Administrator\AppData\Roaming\npm\node_modules\hexo-cli。 初始化博客 创建一个hexo文件夹(可选，不创建也行，我习惯归类，不喜欢将各种东西都放在一起) 打开cmd，移动到该目录下(切换文件夹命令：cd) 创建(不存在则创建)并初始化一个博客文件夹，然后移动到该文件夹下 123hexo init blog #创建并初始化cd blog #移动到blog下npm install #下载所需要的文件 执行启动命令，在浏览器输入：http://localhost:4000 就可以看到页面了。 1hexo server git环境安装​ 在git官网下载git并安装，安装好之后，在cmd中输入命令查看。 1git --version ​ 然后在gitHub上注册一个账号。 创建gitHub Pages 点击头像左侧的+，选择New repository，设置Repository name，格式为：账号名称.github.io(Bangsong.github.io)。Description为项目描述可以不填写，下面选择public(公开项目)，你也只能选public，private是收钱的。 点击Create repository，创建成功。 找到项目的settings，在其中找到Theme Chooser随便选一个主题。 切换到Code界面，点击右侧的Clone or download，查看当前仓库的连接。 接下来就是一系列git的操作了。 目前我git操作不是很懂所以就不再这班门弄斧了，推荐一个教程廖雪峰老师git教程，个人感觉还不错。 结语​ 至此环境就搭建完成了，接下来就是Hexo的主题配置了，又是一段艰辛路…..]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架搭建]]></title>
    <url>%2FBlog%2Fspring%2FSSM%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[第一步：创建maven项目在idea新建项目，选择如下： Maven→勾选Create from archetype→maven-archetype-webapp，然后一直下一步即可创建成功，成功之后会提示是否自动导入包，选择自动导入。 第二步：配置依赖包 在pom.xml文件中配置一系列依赖包。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!-- spring依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-spring依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- datasource依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接器依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签库依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--json解析配置--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.39&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; java目录为Sources root(源文件)，右键将目录标记为 Sources root。放java源码 controller、dao、service分别为：访问控制层、数据持久层、业务逻辑层。util为工具类包。 resources目录为Resources root(资源文件)，右键将目录标记为Resources root。放配置文件 第四步：配置web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" version="2.4"&gt; &lt;!--主配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--字符过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--session保持时间分钟为单位--&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!--监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置和完web.xml之后，里面配置了一些其他的配置文件，接下来逐个配置 配置config.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;import resource="classpath:mybatis/db.xml"/&gt; &lt;import resource="classpath:spring/spring-mybatis.xml"/&gt; &lt;import resource="classpath:spring/spring-tx.xml"/&gt;&lt;/beans&gt; 配置spring-mvc.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:annotation-config /&gt; &lt;!--注解驱动--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;!-- 避免IE执行AJAX时,返回JSON出现下载文件 --&gt; &lt;bean id="fastJsonHttpMessageConverter" class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package="com.dv"/&gt; &lt;!--视图解析--&gt; &lt;bean id="ViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/jsp/" p:suffix=".jsp"/&gt; &lt;!--静态资源--&gt; &lt;mvc:resources mapping="/content/**" location="/WEB-INF/content/"/&gt; &lt;!-- 开启aop，对类代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true" /&gt; &lt;!-- 配置数据库注解aop --&gt; &lt;bean id="dataSourceAspect" class="com.dv.util.DataSourceAspect" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="c" ref="dataSourceAspect"&gt; &lt;aop:pointcut id="tx" expression="execution(* com.dv.service..*.*(..))"/&gt; &lt;aop:before pointcut-ref="tx" method="before"/&gt; &lt;aop:after pointcut-ref="tx" method="after"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 此时，还需要配置config.xml中的配置文件，依次配置： 配置db.properties 123456789101112131415161718192021222324252627#driver=com.mysql.jdbc.Driverjdbc.driver=com.mysql.cj.jdbc.driverjdbc.url=jdbc:mysql://localhost:3306/jdbc.dbnameXSofe = xsofejdbc.dbnameEcharts = echartsjdbc.params = useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=root#配置初始化大小、最小、最大initialSize=0maxActive=8minIdle=0maxIdle=8 #配置获取连接等待超时的时间maxWait=20000validationQuery=select 1 #打开PSCache，并且指定每个连接上PSCache的大小poolPreparedStatements=truemaxPoolPreparedStatementPerConnectionSize=10 #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis=60000 #配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis=1800000 配置db.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 加载db.properties文件 --&gt; &lt;context:property-placeholder location="classpath:mybatis/db.properties"/&gt; &lt;!-- 配置数据源，用于访问mysql数据库($&#123;&#125;这种写法称为占位符，具体值在运行时使用db.properties文件中配置的值) com.alibaba.druid.pool.DruidDataSource--&gt; &lt;bean id="dataSourceXSofe" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameXSofe&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;bean id="dataSourceEcharts" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameEcharts&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;!-- 自定义数据源切换类 --&gt; &lt;bean id="DynamicDataSource" class="com.dv.util.DynamicDataSource"&gt; &lt;!-- 这里可以指定默认的数据源 --&gt; &lt;property name="defaultTargetDataSource" ref="dataSourceXSofe" /&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;!-- 指定lookupKey和与之对应的数据源 --&gt; &lt;entry key="DV" value-ref="dataSourceXSofe"&gt;&lt;/entry&gt; &lt;entry key="Echarts" value-ref="dataSourceEcharts"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 配置spring-mybatis.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 该配置文件是mybatis与spring的整合 --&gt; &lt;!-- 整合的固定写法，配置SqlSessionFactory --&gt; &lt;!-- mybatis文件配置，扫描所有mapper.xml文件 --&gt; &lt;!-- 配置mybatisSqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--&lt;property name="dataSource" ref="dataSource" /&gt;&amp;lt;!&amp;ndash; 使用的数据源 &amp;ndash;&amp;gt;--&gt; &lt;property name="dataSource" ref="DynamicDataSource" /&gt;&lt;!-- 使用的数据源 --&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml" /&gt;&lt;!-- mybatis的配置文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/dv/dao/xml/*Mapper.xml" /&gt;&lt;!-- 自动扫描mapper的xml文件 --&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionTemplate --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 为每个Mapper接口在运行时动态生成实现类 --&gt; &lt;!-- 配置mybatis mapper接口，扫描所有dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.dv.dao.mapper" /&gt;&lt;!-- 自动扫描mapper接口，为每个接口生成MapperFactoryBean --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;!-- 如果有多个数据源的话，须指定使用哪一个 --&gt; &lt;/bean&gt;&lt;/beans&gt; 配置spring-tx.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 该配置文件是mybatis与spring的整合 --&gt; &lt;!-- 整合的固定写法，配置SqlSessionFactory --&gt; &lt;!-- mybatis文件配置，扫描所有mapper.xml文件 --&gt; &lt;!-- 配置mybatisSqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--&lt;property name="dataSource" ref="dataSource" /&gt;&amp;lt;!&amp;ndash; 使用的数据源 &amp;ndash;&amp;gt;--&gt; &lt;property name="dataSource" ref="DynamicDataSource" /&gt;&lt;!-- 使用的数据源 --&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml" /&gt;&lt;!-- mybatis的配置文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/dv/dao/xml/*Mapper.xml" /&gt;&lt;!-- 自动扫描mapper的xml文件 --&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionTemplate --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 为每个Mapper接口在运行时动态生成实现类 --&gt; &lt;!-- 配置mybatis mapper接口，扫描所有dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.dv.dao.mapper" /&gt;&lt;!-- 自动扫描mapper接口，为每个接口生成MapperFactoryBean --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;!-- 如果有多个数据源的话，须指定使用哪一个 --&gt; &lt;/bean&gt;&lt;/beans&gt; 配置mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置mybatis的缓存，延迟加载等等一系列属性 --&gt; &lt;settings&gt; &lt;!-- 该配置影响的所有映射器中配置的缓存的全局开关。默认true --&gt; &lt;setting name="cacheEnabled" value="true" /&gt; &lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。默认false --&gt; &lt;setting name="lazyLoadingEnabled" value="true" /&gt; &lt;!-- 是否允许单一语句返回多结果集（需要兼容驱动）。 默认true --&gt; &lt;setting name="multipleResultSetsEnabled" value="true" /&gt; &lt;!-- 使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。默认true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。 默认false --&gt; &lt;setting name="useGeneratedKeys" value="false" /&gt; &lt;!-- 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 默认 PARTIAL --&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING" /&gt; &lt;!-- 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。默认SIMPLE --&gt; &lt;setting name="defaultExecutorType" value="SIMPLE" /&gt; &lt;!-- 设置超时时间，它决定驱动等待数据库响应的秒数。Not Set (null) --&gt; &lt;setting name="defaultStatementTimeout" value="25" /&gt; &lt;!-- 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 --&gt; &lt;setting name="defaultFetchSize" value="100" /&gt; &lt;!-- 允许在嵌套语句中使用分页（RowBounds）。 If allow, set the false. --&gt; &lt;setting name="safeRowBoundsEnabled" value="false" /&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false" /&gt; &lt;!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&gt; &lt;setting name="localCacheScope" value="SESSION" /&gt; &lt;!-- 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 --&gt; &lt;setting name="jdbcTypeForNull" value="OTHER" /&gt; &lt;!-- 指定哪个对象的方法触发一次延迟加载。 --&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString" /&gt; &lt;!-- 打印mybatis中Sql语句--&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt; &lt;!-- mybatis自己的配置文件(mybatis自己单独使用和与spring整合在一起使用这两种情况的配置方式是完全不一样的) --&gt; &lt;!--&lt;typeAliases&gt;--&gt; &lt;!--&lt;package name="org.eop.spring.mvc.mybatis.bean"/&gt;--&gt; &lt;!--&lt;/typeAliases&gt;--&gt;&lt;/configuration&gt; 上述配置中，我配置的是两个数据源，其中通过注解切换。详情见我的另一篇文章：SSM多数据源注解动态切换。 配置完之后的目录： 测试： 创建一个homeController，将项目默认创建的index.jsp文件移动到jsp/home下。 homeController代码： 12345678910111213package com.dv.controller; import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping("/")public class homeController &#123; @RequestMapping public String index()&#123; return "home/index"; &#125;&#125; 然后配置一下tomcat，tomcat自行下载。 测试结果： 至此，SSM框架搭建完成，数据库的测试就不测试了，自行测试吧。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM多数据源注解动态切换]]></title>
    <url>%2FBlog%2Fspring%2FSSM%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%B3%A8%E8%A7%A3%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[创建项目就跳过了，可以查看我之前写的一篇SSM框架搭建 此文章前提是SSM基本配置已经完成，可以连接单数源。 有两种方法，但大致一样，第一种是第一次找到的，但只能在controller层注解，从代码分工来讲，controller不应该处理数据方面的问题，所以第一种方法不推荐，第二种是在service层注解，推荐使用。 方法1第一步：修改db.properties文件 123456789101112131415161718192021222324252627#driver=com.mysql.jdbc.Driverjdbc.driver=com.mysql.cj.jdbc.driverjdbc.url=jdbc:mysql://localhost:3306/jdbc.dbnameDV = dv #数据源1jdbc.dbnameEcharts = echarts #数据源2jdbc.params = useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=root#配置初始化大小、最小、最大initialSize=0maxActive=8minIdle=0maxIdle=8#配置获取连接等待超时的时间maxWait=20000validationQuery=select 1#打开PSCache，并且指定每个连接上PSCache的大小poolPreparedStatements=truemaxPoolPreparedStatementPerConnectionSize=10#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis=60000#配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis=1800000 第二步：配置db.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 加载db.properties文件 --&gt; &lt;context:property-placeholder location="classpath:mybatis/db.properties"/&gt; &lt;!-- 配置数据源，用于访问mysql数据库($&#123;&#125;这种写法称为占位符，具体值在运行时使用db.properties文件中配置的值) com.alibaba.druid.pool.DruidDataSource--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameDV&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;bean id="dataSourceE" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameEcharts&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;!-- 自定义数据源切换类 --&gt; &lt;bean id="dynamicDataSource" class="com.DV.DataSource.DynamicDataSource"&gt; &lt;!-- 这里可以指定默认的数据源 --&gt; &lt;property name="defaultTargetDataSource" ref="dataSource" /&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;!-- 指定lookupKey和与之对应的数据源 --&gt; &lt;entry key="dataSource" value-ref="dataSource"&gt;&lt;/entry&gt; &lt;entry key="dataSourceE" value-ref="dataSourceE"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 上面已经配置了多个数据源，在最下面指定切换数据源的类，以及数据源。 第三步：在spring-mybatis.xml（spring和mybatis整合配置文件）将数据源指定为多数据源切换的id,即：dynamicDataSource。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 该配置文件是mybatis与spring的整合 --&gt; &lt;!-- 整合的固定写法，配置SqlSessionFactory --&gt; &lt;!-- mybatis文件配置，扫描所有mapper.xml文件 --&gt; &lt;!-- 配置mybatisSqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--&lt;property name="dataSource" ref="dataSource" /&gt;&amp;lt;!&amp;ndash; 使用的数据源 &amp;ndash;&amp;gt;--&gt; &lt;property name="dataSource" ref="dynamicDataSource" /&gt;&lt;!-- 使用的数据源 --&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml" /&gt;&lt;!-- mybatis的配置文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/DV/dao/xml/*Mapper.xml" /&gt;&lt;!-- 自动扫描mapper的xml文件 --&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionTemplate --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 为每个Mapper接口在运行时动态生成实现类 --&gt; &lt;!-- 配置mybatis mapper接口，扫描所有dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.DV.dao.mapper" /&gt;&lt;!-- 自动扫描mapper接口，为每个接口生成MapperFactoryBean --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;!-- 如果有多个数据源的话，须指定使用哪一个 --&gt; &lt;/bean&gt;&lt;/beans&gt; 第四步：在事务管理的配置文件中，修改数据源，同上。并加入切面配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 事务配置可以抽象为四部分：数据源、事务管理器、事务属性、事务代理 --&gt; &lt;!-- 数据源：支持事务的数据资源，如数据库 --&gt; &lt;!-- 事务管理器：JDBC事务管理器、EJB容器事务管理器、分布式事务管理器等 --&gt; &lt;!-- 事务属性：事务的传播属性等 --&gt; &lt;!-- 事务代理：将事务属性应用到事务目标对象的方法上，且由事务管理器来管理、如自动的提交或回滚事务 --&gt; &lt;!-- 事务管理 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 对insert,update,delete 开头的方法进行事务管理,只要有异常就回滚 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" rollback-for="java.lang.Throwable"/&gt; &lt;tx:method name="update*" propagation="REQUIRED" rollback-for="java.lang.Throwable"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED" rollback-for="java.lang.Throwable"/&gt; &lt;!-- select,count开头的方法,开启只读,提高数据库访问性能 --&gt; &lt;tx:method name="select*" read-only="true"/&gt; &lt;tx:method name="count*" read-only="true"/&gt; &lt;!-- 对其他方法 使用默认的事务管理 --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id="serviceMethods" expression="execution(* com.DV.service..*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="serviceMethods"/&gt; &lt;/aop:config&gt; &lt;!-- 配置使Spring采用CGLIB代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!-- 对dataSource 数据源进行事务管理 --&gt; &lt;!--&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" p:dataSource-ref="dataSource"/&gt;--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" p:dataSource-ref="dynamicDataSource"/&gt; &lt;!-- 使用annotation注解方式配置事务,启用对事务注解的支持 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.DV.service.impl.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 注意最下面的切面配置 第五步：在spring-mvc(spring和mvc整合配置文件)中，开启aop，对类代理 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:annotation-config /&gt; &lt;!--注解驱动--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;!-- 避免IE执行AJAX时,返回JSON出现下载文件 --&gt; &lt;bean id=&quot;fastJsonHttpMessageConverter&quot; class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 开启aop，对类代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; &lt;bean id=&quot;logAopAction&quot; class=&quot;com.DV.DataSource.LogAopAction&quot;/&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.DV.controller&quot;/&gt; &lt;!--视图解析--&gt; &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; p:prefix=&quot;/WEB-INF/jsp/&quot; p:suffix=&quot;.jsp&quot;/&gt; &lt;!--静态资源--&gt; &lt;mvc:resources mapping=&quot;/content/**&quot; location=&quot;/WEB-INF/content/&quot;/&gt;&lt;/beans&gt; 注意配置中开启aop代码 第六步：创建自定义数据源选择器类DynamicDataSource 123456789101112131415package com.DV.DataSource; import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource; public class DynamicDataSource extends AbstractRoutingDataSource &#123; private static final ThreadLocal&lt;String&gt; dataSourceKey = new InheritableThreadLocal&lt;String&gt;(); public static void setDataSourceKey(String dataSource)&#123; dataSourceKey.set(dataSource); &#125; @Override protected Object determineCurrentLookupKey() &#123; return dataSourceKey.get(); &#125; &#125; 第七步：自定义注解DataSourceChange 123456789101112131415161718package com.DV.DataSource; import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; /** * 定义DataSource的注解 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Documentedpublic @interface DataSourceChange &#123; String dataSource() default "";&#125; 第八步：前置通知（这里切的是controller） 1234567891011121314151617181920212223242526272829303132333435package com.DV.DataSource;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import java.lang.reflect.Method;@Aspectpublic class LogAopAction &#123; //配置接入点 @Pointcut("execution(* com.DV.controller..*.*(..))") private void controllerAspect()&#123;&#125;//定义一个切入点 @Before("controllerAspect()") public void dataSwitch(JoinPoint joinPoint)&#123; Signature signature = joinPoint.getSignature(); MethodSignature methodSignature =(MethodSignature) signature; Method method = methodSignature.getMethod(); DataSourceChange data = null; String dataSource = ""; if(method != null)&#123; data = method.getAnnotation(DataSourceChange.class); if(data != null)&#123; dataSource = data.dataSource(); if(dataSource != null)&#123; DynamicDataSource.setDataSourceKey(dataSource); &#125; &#125; &#125; &#125;&#125; 在conrtoller中的方法上使用：@DataSourceC(dataSource=”数据源ID”)即可，测试代码如下： 1234567@RequestMapping("test")@ResponseBody@DataSourceC(dataSource="dataSourceE")public List test()&#123; List result = dataGraphService.test(); return result;&#125; 测试结果如下： 如图，测试通过，可以注解改变数据源。参考文章地址：https://blog.csdn.net/weixin_38897274/article/details/78529940 方法21、创建接口DataSource，用于定义注解。 123456789101112package com.DV.entity;import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface DataSource &#123; String value();&#125; 2、定义类DynamicDataSource，用于重写AbstractRoutingDataSource以及获取和设置数据源 1234567891011121314151617181920212223package com.DV.entity;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource &#123; public static final ThreadLocal&lt;String&gt; holder = new ThreadLocal&lt;String&gt;(); //设置数据源 public static void setDataSource(String datasource) &#123; holder.set(datasource); &#125; //获取数据源 private String getDataSource() &#123; return holder.get(); &#125; //清除数据源 public static void clearDataSource() &#123; holder.remove(); &#125; @Override protected Object determineCurrentLookupKey() &#123; return getDataSource(); &#125;&#125; 3、定义类DataSourceAspect，用于AOP切面。 12345678910111213141516171819202122232425262728293031323334package com.DV.entity;import java.lang.reflect.Method;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.reflect.MethodSignature;public class DataSourceAspect &#123; //切换数据源 public void before(JoinPoint point) &#123; Object target = point.getTarget(); System.out.println(target.toString()); String method = point.getSignature().getName(); System.out.println(method); Class&lt;?&gt;[] classz = target.getClass().getInterfaces(); Class&lt;?&gt;[] parameterTypes = ((MethodSignature) point.getSignature()) .getMethod().getParameterTypes(); try &#123; Method m = classz[0].getMethod(method, parameterTypes); System.out.println(m.getName()); if (m != null &amp;&amp; m.isAnnotationPresent(DataSource.class)) &#123; DataSource data = m.getAnnotation(DataSource.class); DynamicDataSource.setDataSource(data.value()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //清除数据源，使用默认数据源 public void after()&#123; DynamicDataSource.clearDataSource(); &#125;&#125; 4、最后，还需要修改spring-mvc配置文件。 1234567891011&lt;!-- 开启aop，对类代理 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true" /&gt;&lt;!-- 配置数据库注解aop --&gt;&lt;bean id="dataSourceAspect" class="com.DV.entity.DataSourceAspect" /&gt;&lt;aop:config&gt; &lt;aop:aspect id="c" ref="dataSourceAspect"&gt; &lt;aop:pointcut id="tx" expression="execution(* com.DV.service..*.*(..))"/&gt; &lt;aop:before pointcut-ref="tx" method="before"/&gt; &lt;aop:after pointcut-ref="tx" method="after"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 5、在service方法中使用 12345678910111213141516package com.DV.service;import com.DV.entity.DataSource;import java.util.List;import java.util.Map;public interface dataGraphService &#123; List&lt;Map&gt; echartSet(String corp_id, String type); @DataSource("Echarts") List&lt;Map&gt; test();&#125;---------------------本文来自 XGamerR 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/BangSong/article/details/80775249?utm_source=copy 测试可以切换。 参考文章地址：https://blog.csdn.net/wolfjin/article/details/72465668]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc初识]]></title>
    <url>%2FBlog%2Fspring%2Fspringmvc%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、建立项目打开Idea，选择新建项目。 选择Maven项目，勾选上方的Create from archetype。选择maven-archetype-webapp(若此处不是选的maven则需要自己手动导入所需包) GroupId和Artifactld自己随便填写，最好有意义，然后一直next即可。 二、配置springmvc创建成功之后，如图。点Enable-auto-import 查看文件，找到pom.xml，在此处配置springmvc需要的包，此功能是maven的功能。打开pom.xml，配置所需的依赖包。(此配置代码要放到dependencies标签中) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; 以及bulid 12345678910111213&lt;build&gt; &lt;finalName&gt;springmvcdemo_1&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 至此，只是配置好了所需要的依赖包。配置好之后在外部包处则会看到所配置的依赖包，如图。 接下来就是配置servlet前端控制器。如图中，找到web.xml文件打开进行配置。 配置如下： 主要配置代码： 12345678910111213141516171819&lt;!--servlet前端控制器--&gt; &lt;servlet&gt; &lt;!--前端控制器名字--&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--springmvc其他配置的配置文件(如：处理器映射器、处理器适配器、视图解析器) 若不指定则默认找/WEB-INF/前端控制器名字-servlet.xml --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--路径访问--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置好之后，在resource目录下创建dispathcer-servlet.xml文件，右键此目录，选择XML配置文件，选择spring配置，名字对应的为上面配置中的init-param中的param-value里面的那个文件名。 创建好之后如下： 配置代码如下： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop· http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd "&gt; &lt;!--spring注解驱动器--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--注解适配器--&gt; &lt;context:component-scan base-package="com.rzp.test.controller" /&gt; &lt;!--视图解析器--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 上述配置中的视图解析器中，bean里面的配置分配为解析jsp视图，视图前缀配置，视图后缀配置，在此处配置这些之后在控制器类中返回视图时，则不需要写视图全路径了。不配做则需要返回视图的全路径。配置后了之后，就可以开始写控制器类了。首先在main下创建一个java目录，并将java目录标记为Sources Root，如图： 然后在java目录下创建一个包：包名可以自己随便定，但是此包名要和上述配置中的注解适配器中的base-package的值。创建好之后在其包中创建一个java类，创建好之后在类中写代码，如图： 其中@Controller是将此类标记为一个控制器。至此一个简单的springmvc项目则配置成功。然后配置一下tomcat，点击运行即可查看效果。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lisp的永恒之道]]></title>
    <url>%2FBlog%2FLisp%2FLisp%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[Lisp的永恒之道原文地址：http://www.cnblogs.com/weidagang2046/archive/2012/06/03/tao_of_lisp.html Lisp之魅长久以来，Lisp一直被许多人视为史上最非凡的编程语言。它不仅在50多年前诞生的时候带来了诸多革命性的创新并极大地影响了后来编程语言的发展，即使在一大批现代语言不断涌现的今天，Lisp的诸多特性仍然未被超越。当各式各样的编程语言摆在面前，我们可以从运行效率、学习曲线、社区活跃度、厂商支持等多种不同的角度进行评判和选择，但我特别看中的一点在于语言能否有效地表达编程者的设计思想。学习C意味着学习如何用过程表达设计思想，学习Java意味着学习如何用对象表达设计思想，而虽然Lisp与函数式编程有很大的关系，但学习Lisp绝不仅仅是学习如何用函数表达设计思想。实际上，函数式编程并非Lisp的本质，即使在已经掌握lambda、高阶函数、闭包、惰性求值等函数式编程概念之后，学习Lisp仍然能够大大加深我们对编程的理解。学习Lisp所收获的是如何自由地表达设计思想，这正是Lisp最大的魅力所在，也是这门古老的语言仍然具有很强生命力的根本原因。 Lisp之源Lisp意为列表处理(List Processing)，源自设计者John McCarthy于1960年发表的一篇论文《符号表达式的递归函数及其机器计算》。McCarthy在这篇论文中向我们展示了用一种简单的数据结构S表达式(S-expression)来表示代码和数据，并在此基础上构建一种完整的语言。Lisp语言形式简单、内涵深刻，Paul Graham在《Lisp之根源》中将其对编程的贡献与欧几里德对几何的贡献相提并论。 Lisp之形然而，与数学世界中简单易懂的欧氏几何形成鲜明对比，程序世界中的Lisp却一直是一种古老而又神秘的存在，真正理解其精妙的人还是少数。从表面上看，Lisp最明显的特征是它“古怪”的S表达式语法。S表达式是一个原子(atom)，或者若干S表达式组成的列表(list)，表达式之间用空格分开，放入一对括号中。“列表“这个术语可能会容易让人联想到数据结构中的链表之类的线形结构，实际上，Lisp的列表是一种可嵌套的树形结构。下面是一些S表达式的例子: 123456789foo()(a b (c d) e)(+ (* 2 3) 5)(defun factorial (N) (if (= N 1) 1 (* N (factorial (- N 1))) )) 据说，这个古怪的S表达式是McCarthy在发明Lisp时候所采用的一种临时语法，他实际上是准备为Lisp加上一种被称为M表达式(M-expression)的语法，然后再把M表达式编译为S表达式。用一个通俗的类比，S表达式相当于是JVM的字节码，而M表达式相当于Java语言，但是后来Lisp的使用者都熟悉并喜欢上了直接用S表达式编写程序，并且他们发现S表达式有许多独特的优点，所以M表达式的引入也就被无限期延迟了。 许多Lisp的入门文章都比较强调Lisp的函数式特性，而我认为这是一种误导。作为Lisp的语法基础，Lisp最大的奥秘不在函数式编程，而就在S表达式本身。“S表达式”是程序的一种形，正如“七言”是诗的一种形，“微博”是信息的一种形。人们常认为语法形式不重要，重要的是语言的语义，比如，Java用throw关键字表示“抛出异常”，而Python用raise关键字，二者语法形式不同，但并无语义上的差别。不过，有时候形式的结构特征的确非常重要。唐诗与宋词有着不同的韵味，难道与诗词的形式没有关系？微博和博客都可以作为信息交流的工具，但二者在文化内涵上完全不同，难道也与形式没有关系？语法是语义的载体，形式是实质的寄托，要表达不同的实质，必须有与之配合的形式，因此，Lisp之所以成为非凡的语言，离不开它非凡的语法形式：S表达式。 Lisp之道一门语言能否有效地表达编程者的设计思想取决于其抽象机制的语义表达能力。根据抽象维度的不同，常见的语言抽象机制形成了面向过程、面向对象、函数式、并发式等不同的范式。当我们采用某一种语言，基本上就表示我们已经“面向xxx“了，我们的思维方式和解决问题的手段就会依赖于语言所提供的抽象方式。比如，采用Java语言通常意味着采用面向对象分析设计；采用Erlang通常意味着按Actor模型对并发任务进行建模。 有经验的程序员都知道，无论是面向xxx编程，程序设计都有一条“抽象原则“：what与how解耦，即把语义的声明式表达和实现细节分开，使得程序更容易理解，也更具灵活性。但是，普通语言的问题就在于表达what的手段非常有限，无非是过程、类、接口、函数、Actor等几种语义，这就要求我们在分析建模时必须把领域模型抽象为这些基本语义。但这往往不是许多领域问题最自然的抽象方式，比如，你完全可以在C语言中通过若干函数来做到make file所做的事情，但C代码很难像make file那样声明式地体现出target、depends等语义，它们只会作为实现细节被淹没在一个个的C函数之中。对于自动化构建问题来讲，最自然的抽象应该是像make file一样把target、depends语义作为“一等公民”，这样我们一看make file就知道有哪些target，它们之间有何种依赖关系。也就是说在描述文件依赖关系的能力上make file显然比C语言更加强大。采用面向对象或是函数式等其它范式去实现make file的功能也会遇到同样的困难，这是因为target、depends语义所代表的抽象维度与面向过程、面向对象以及函数式编程的抽象维度是正交的。 用普通语言解决领域问题所遇到的困难背后正是这些语言的“刚性”特征，它要求我们必须以语言的抽象维度去分析和解决问题，虽然有时候这显得不那么自然。这种刚性与我们上一节中谈到的语法和语义之间的关系有着紧密的联系。因为，任何一门编程语言所提供的语法形式都是有限的，而普通语言中语法和语义是紧耦合关系，比如，C语言中printf(“hello %s”, name)符合函数调用语法，它表达了函数调用语义，除此之外别无他义；Java中interface IRunnable { … }符合接口定义语法，它表达了接口定义语义，除此之外别无他义。在语法和语义紧耦合关系下，普通语言所能表达的语义类型也是有限的，不能凭空创造出更多设计之外的语义。 而Lisp与此截然不同，虽然它只提供S表达式这一种语法形式，比普通语言更加精简，但神奇的是Lisp所能表达的语义是无限的！无限？！为什么？这可能吗？我们马上就要揭开Lisp的神秘面纱了。当你看到Lisp的(f a (b c))的时候，你会想到什么？会不会马上联想到函数求值或是宏扩展？就像在C语言里看到gcd(10, 15)马上想到函数调用，或者在Java里看到class A马上想到类定义一样。如果真是这样，这就是你理解Lisp的一道障碍，因为你已经习惯了顺着语言去思考，总是在想这一句话机器怎么解释执行？那一句话又对应语言的哪个特性？理解Lisp要反过来，让语言顺着你，Lisp的(f a (b c))可以是任何语义，完全由你来定，它可以是函数定义、类定义、数据库查询、文件依赖关系，异步任务的执行关系，业务规则 … 下面我准备先通过几个具体的例子逐步展示Lisp的本质。需要说明的是，由于Lisp的S表达式和XML的语法形式都是一种树形结构，在语义表达方面二者并无本质的差别，为了理解方便，下面我暂且用多数人更为熟悉的XML来写代码，请记住我们可以很轻易地把XML代码和Lisp代码相互转换。 首先，我们可以轻易地用XML来定义一个求两个数最大公约数的函数： 12345678910111213141516171819202122232425&lt;func name='gcd' return_type='int'&gt; &lt;params&gt; &lt;a type='int'/&gt; &lt;b type='int'/&gt; &lt;/params&gt; &lt;body&gt; &lt;if&gt; &lt;equals&gt; &lt;a/&gt; &lt;int&gt;0&lt;/int&gt; &lt;/equals&gt; &lt;/if&gt; &lt;then&gt; &lt;return&gt;&lt;b/&gt;&lt;/return&gt; &lt;/then&gt; &lt;else&gt; &lt;return&gt; &lt;gcd&gt; &lt;modulo&gt;&lt;b/&gt;&lt;a/&gt;&lt;/modulo&gt; &lt;a/&gt; &lt;/gcd&gt; &lt;/return&gt; &lt;/else&gt; &lt;/body&gt;&lt;/func&gt; 其次，我们可以用它来定义类： 12345678910111213&lt;class name="Computer"&gt; &lt;field access="private" type="MainBoard" name="main-board" /&gt; &lt;field access="private" type="CPU" name="cpu" /&gt; &lt;field access="private" type="Memory" name="memory" /&gt; &lt;method access="public" return_type="boolean" name="powerOn" /&gt; &lt;params&gt;...&lt;/params&gt; &lt;body&gt;...&lt;/body&gt; &lt;/method&gt; &lt;method access="public" return_type="boolean" name="powerOff" /&gt; &lt;params&gt;...&lt;/params&gt; &lt;body&gt;...&lt;/body&gt; &lt;/method&gt;&lt;/class&gt; 还可以轻易地用它来编写关系查询： 12345678910111213141516&lt;sql&gt; &lt;select&gt; &lt;column name="employees.id" /&gt; &lt;column name="bonus.amount" /&gt; &lt;/select&gt; &lt;from&gt; &lt;table name="employees" /&gt; &lt;table name="bonus" /&gt; &lt;/from&gt; &lt;where&gt; &lt;equals&gt; &lt;column name="employees.id" /&gt; &lt;column name="bonus.employee_id" /&gt; &lt;/equals&gt; &lt;/where&gt;&lt;/sql&gt; 还可以用它来实现类似make file的自动化构建(语法取自ant)： 12345678910111213141516171819&lt;project name=&quot;MyProject&quot; default=&quot;dist&quot; basedir=&quot;.&quot;&gt; &lt;property name=&quot;src&quot; location=&quot;src&quot;/&gt; &lt;property name=&quot;build&quot; location=&quot;build&quot;/&gt; &lt;property name=&quot;dist&quot; location=&quot;dist&quot;/&gt; &lt;target name=&quot;init&quot;&gt; &lt;mkdir dir=&quot;$&#123;build&#125;&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;compile&quot; depends=&quot;init&quot; description=&quot;compile the source &quot; &gt; &lt;javac srcdir=&quot;$&#123;src&#125;&quot; destdir=&quot;$&#123;build&#125;&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;dist&quot; depends=&quot;compile&quot; description=&quot;generate the distribution&quot; &gt; &lt;mkdir dir=&quot;$&#123;dist&#125;/lib&quot;/&gt; &lt;jar jarfile=&quot;$&#123;dist&#125;/lib/MyProject-$&#123;DSTAMP&#125;.jar&quot; basedir=&quot;$&#123;build&#125;&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;clean&quot; description=&quot;clean up&quot; &gt; &lt;delete dir=&quot;$&#123;build&#125;&quot;/&gt; &lt;delete dir=&quot;$&#123;dist&#125;&quot;/&gt; &lt;/target&gt;&lt;/project&gt; 一口气举了这么多个例子，不知道你是否发现了XML和S表达式这类树形语法在语义构造方面有着特别的“柔性”？我们可以轻易地用树形语法构造出函数、变量、条件判断语义，类、属性、方法语义，可以轻易地构造出关系模型的select、where语义，还可以轻易地构造出make的target、depends语义，等等数不清的语义。在普通语言里，你可以定义一个函数、一个类，但你无法为C语言增加匿名函数特性，也没法给Java语言加上RAII语义，甚至连自己创造一个foreach关键字都不行，而自定义语义意味着在Lisp之上你创造了一门语言！不管是面向过程，面向对象，函数式，还是关系模型，在Lisp里统统都变成了一种DSL，而Lisp本身也就成了一种定义语言的语言，即元语言(Meta Language)。 Lisp的柔性与S表达式有着密切的关系。Lisp并不限制你用S表达式表达什么语义，同样的S表达式语法可以表达各种不同领域的语义，这就是语法和语义解耦。在有限的语法规则下，如果说普通语言的刚性源于“语法和语义紧耦合”，那么Lisp的柔性正是源于“语法和语义解耦”！这使得Lisp可以随意地构造各种领域的DSL，而不强制用某一种范式或是领域视角去分析和解决问题。本质上，Lisp编程代表了一种超越了普通编程范式的范式，这就是Lisp之道：面向语言编程(LOP, Language Oriented Programming)。Wikipedia上是这样描述LOP的： Language oriented programming (LOP) is a style of computer programming in which, rather than solving problems in general-purpose programming languages, the programmer creates one or more domain-specific languages for the problem first, and solves the problem in those languages … The concept of Language Oriented Programming takes the approach to capture requirements in the user’s terms, and then to try to create an implementation language as isomorphic as possible to the user’s descriptions, so that the mapping between requirements and implementation is as direct as possible. LOP范式的基本思想是从问题出发，先创建一门描述领域模型的DSL，再用DSL去解决问题，它具有高度的声明性和抽象性。SQL、make file、CSS等DSL都可以被认为是LOP的具体实例，下面我们再通过两个常见的例子来理解LOP的优势。 例1：在股票交易系统中，交易协议定义了若干二进制的消息格式，交易所和客户端需要对消息进行编码和解码。 消息格式是一种抽象的规范，本身不对语言做任何的限制，你可以用C，C++，Java，或者Python。普通的实现方式是按照消息格式规范，在相应的语言中定义消息结构，并编写相应的编解码函数。假设为一个消息定义结构和实现编解码函数的工作量为M，不同消息类型的数量为N，这种方式的工作量大致为MN。也就是说每增加一种消息类型，就需要为该消息定义结构，实现编解码函数，引入bug的可能性当然也和MN成正比。如果仔细观察不难发现，各个消息结构其实是高度类似的，编解码函数也大同小异，但是普通语言却找不到一种抽象机制能表达这种共性，比如，我们无法通过面向对象的方法定义一个基类把消息结构的共性抽象出来，然后让具体的消息去继承它，达到复用的目的。这正是由于普通语言的抽象维度限制所致，在普通语言中，你只能从函数、类、接口等维度对事物进行抽象，而恰好消息格式共性所在的维度与这些抽象维度并不匹配。 其实，不同消息类型的共性在于它们都具有相同的领域语义，比如，“某字段是另一个字段的md5码”就是一种消息格式的领域语义，这种领域语义是OOP的抽象机制无法描述的，但是我们却可以通过DSL直接声明式地描述它。LOP的思路是先创建一门消息定义DSL，比如，类似Google的Protocol Buffer，Android的AIDL。然后，通过DSL编写消息定义文件，直接声明式地描述消息的结构特征，比如，我们可以声明式地描述“某字段是另一个字段的md5码”。我们还需要为DSL开发编译器用于生成C、Java等通用语言的消息定义和编解码函数。 有了消息定义DSL和编译器之后，由于DSL编写消息定义是一种高度声明式的编程方法，每增加一种消息只需要多编写一个消息定义文件而已，工作量几乎可以忽略不计。所有的工作量都集中在DSL的设计和编译器的开发上，工作量是一个常数C，与消息的数量没有关系；质量保证方面也只需要关注编译器这一点，不会因为增加新的消息类型而引入bug。 例2：在图书管理系统中，需要支持在管理界面上对书籍、学生、班级等各种实体进行管理操作。 如果按传统的三层架构，一般需要在后端程序中为每一种实体定义一个类，并定义相应的方法实现CRUD操作，与之相应的，还需要在前端页面中为每一个实体编写相应的管理页面。这些实体类的CRUD操作都是大同小异的，但细节又各不相同，虽然我们很想复用某些共同的设计实现，但OOP所提供的封装、继承、多态等抽象机制不足以有效捕获实体之间的共性，大量的代码还是必须放在子类中来完成。比如，Student和Book实体类的实现非常相似，但是如果要通过OOP的方式去抽象它们的共性，得出的结果多半是Entity这样的大而空的基类，很难起到复用的效果。 其实，不同实体之间的共性还是在于它们具有相同的领域语义，比如：实体具有属性，属性具有类型，属性具有取值范围，属性具有可读取、可编辑等访问属性，实体之间有关联关系等。LOP方法正是直接面向这种领域语义的。采用LOP方法，我们并不需要为每一个实体类单独编写CRUD方法，也不需要单独编写管理页面，只需要定义一种DSL并实现其编译器；然后，用DSL声明式地编写实体描述文件，去描述实体的属性列表，属性的类型、取值范围，属性所支持的操作，属性之间的关系和约束条件等；最后，通过这个实体描述文件自动生成后端的实体类和前端管理页面。采用LOP，不论前后端采用何种技术，Java也好，C#也好，JSP也好，ASP.NET也好，都可以自动生成它们的代码。采用LOP的工作量和质量都集中在DSL的设计和编译器的开发，与实体的数量无关，也就是说，越是庞大的系统，实体类越多越是能体现LOP的优势。 通过上面两个小例子我们可以感受到，LOP是一种面向领域的，高度声明式的编程方式，它的抽象维度与领域模型的维度完全一致。LOP能让程序员从复杂的实现细节中解脱出来，把关注点集中在问题的本质上，从而提高编程的效率和质量。 接下来的问题是如果需要为某领域设计DSL，我们是应该发明一门类似SQL这样的专用DSL呢，还是用XML或S表达式去定义DSL呢？它们各有何优缺点呢？ 我认为采用XML或S表达式定义DSL的优点主要有：1) SQL、make file、CSS等专用DSL都只能面向各自的领域，而一个实际的领域问题通常是跨越多个领域的，有时我们需要将不同领域融合在一起，但是由于普通语言的刚性，多语言融合通常会是一件非常困难的事情，而XML和S表达式语法结构的单一性和“代码及数据”的特点使得跨领域融合毫无障碍。2) 在为DSL开发编译器或解释器的方面，二者难度不同。对XML和S表达式定义的DSL进行语法分析非常简单，相比之下，对SQL这样的专用DSL进行语法分析，虽然可以借助Lex、Yacc、ANTLR等代码生成工具，但总的来讲复杂度还是要明显高一些。 当然，XML和S表达式的优点也正好是其缺点，由于XML和S表达式的语法形式是固定的，不能像专用DSL那样自由地设计语法。所以，一般来讲专用DSL的语法显得更加简洁。换句话说，XML和Lisp其实是在语法和语义间做了一个交换，用语法的限制换来了语义的灵活。 Lisp之器接下来我们继续探讨DSL的解释执行问题。DSL代码的解释执行一般分为3种典型的方式：1) 通过专门的解释器解释执行；2) 编译生成其他语言的代码，再通过其他语言的解释器解释执行(或编译运行)；3) 自解释。比如，第1类的代表是SQL，上一节举的两个例子都属于第2类，而第3类自解释正是Lisp的特色。 为了理解自解释，我们可以先从内部DSL的解释执行说起。内部DSL是指嵌入在宿主语言中的DSL，比如，Google Test单元测试框架定义了一套基于流畅接口(Fluent Interface)的C++单元测试DSL。从语义构造的角度看，内部DSL直接借用宿主语言的语法定义了自己的领域语义，是一种语法和语义解耦；从解释执行的角度看，内部DSL是随宿主语言的解释器而自动解释的，不需要像外部DSL一样开发专门的解释器，因而实现的代价很低。当然，并不是说设计内部DSL不用关心任何的解释实现，实际上，还是需要熟悉宿主语言的特性，并利用该特性使得DSL能随着宿主语言的解释器得到解释执行。 Lisp拥有强大的自解释特性，这得益于独一无二的Lisp之器：宏(macro)。宏使得Lisp编写的DSL可以被Lisp解释器直接解释执行，这在原理上与内部DSL是相通的，只是内部DSL一般是利用宿主语言的链式调用等特性，通常形式简陋，功能有限，而Lisp的宏则要强大和灵活得多。 C语言中也有宏的概念，不过Lisp的宏与C语言的宏完全不同，C语言的宏是简单的字符串替换。比如，下面的宏定义： 1#define square(x) (x*x) square(1+1)的期望结果是4，而实际上它会被替换成(1+1*1+1)，结果是3。这个例子说明，C语言的宏只在预编译阶段进行简单的字符串替换，对程序语法结构缺乏理解，非常脆弱。Lisp的宏不是简单的字符串替换，而是一套完整的代码生成系统，它是在语法解析的基础上把Lisp代码从一种形式转换为另一种形式，本质上起到了普通语言编译器的作用。不同的是，普通编译器是把一种语言的代码转换为另一种语言的代码，比如，Java编译器把Java代码转换成Java字节码；而Lisp宏的输入和输出都是S表达式，它本质上是把一种DSL转换为另一种DSL。下面的例子是宏的一个典型用法。 例3：假设Lisp解释器已经具备解释执行面向过程DSL的能力，需要实现类似ant的自动化构建工具。 我们可以基于宏构建一门类ant的DSL，宏的作用是把类ant DSL通过宏展开变成面向过程的DSL，最后被Lisp解释器所解释执行。这样用Lisp编写的ant DSL就不需要被编译为其他语言，也不需要像XML的ant一样依赖于专门的解释器了。 当然，和开发专门的解释器/编译器相比，Lisp的宏也并非没有缺点，宏难以理解，开发和调试更加困难。到底是开发专门的解释器/编译器还是直接采用宏应该视具体情况而定。 总结Lisp采用单一的S表达式语法表达不同的语义，实现了语法和语义解耦。这使得Lisp具有强大的语义构造能力，擅长于构造DSL实现面向语言编程，而宏使得Lisp具有自解释能力，让不同DSL之间的转换游刃有余。进入Lisp的世界应当从理解面向语言编程入门，这是Lisp之道，而函数式编程和宏皆为Lisp之器，以道驭器方为正途。 后记本文是我学习Lisp的一个总结，也是写给有兴趣学习Lisp的程序员的入门资料。必须说明，我还是一个标准的Lisp初学者，几乎没有写过像样的Lisp程序，文中的错误和不足在所难免，希望读者批评指正，感谢！]]></content>
      <categories>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青春，曾经的肆无忌惮]]></title>
    <url>%2FBlog%2F%E5%93%9F%EF%BC%8C%E6%96%87%E8%89%BA%E5%93%A6%EF%BC%81%2F%E9%9D%92%E6%98%A5%EF%BC%8C%E6%9B%BE%E7%BB%8F%E7%9A%84%E8%82%86%E6%97%A0%E5%BF%8C%E6%83%AE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;我们永远不会忘记曾经，就像我们不曾忘记我们是谁。不管时代如何变迁，我们都无法回到曾经的那个年代，找回曾经的我们。所以我们喜欢上了回忆，习惯上了怀念。 &nbsp;&nbsp;&nbsp;&nbsp;我们会在某个夜深人静，想起某个时光里的喧闹。拿起微微泛黄的照片，才发现我们变老了。看着照片熟悉又陌生的脸庞，泪抹杀了笑脸。 &nbsp;&nbsp;&nbsp;&nbsp;那个年代，我们幼稚中带些稳重。 &nbsp;&nbsp;&nbsp;&nbsp;那个年代，我们幸福中带些悲伤。 &nbsp;&nbsp;&nbsp;&nbsp;那个年代，我们脆弱中带些坚强。 &nbsp;&nbsp;&nbsp;&nbsp;现在，我们知道了那个年代叫做青春。 &nbsp;&nbsp;&nbsp;&nbsp;在青春，我们那么的肆无忌惮。在现在，我们如此的如履薄冰。曾经，我们放肆的笑，撕心的哭，累了以后才发现原来还有人一直陪在身边。如今，我们虚伪的笑，默默的哭，醒了以后，却发现原来一直陪在身边的人都已不在。 &nbsp;&nbsp;&nbsp;&nbsp;因为冲动，所以我们年轻。 &nbsp;&nbsp;&nbsp;&nbsp;因为放肆，所以我们青春。 &nbsp;&nbsp;&nbsp;&nbsp;关于那些曾经的肆无忌惮，我们习惯的叫做了青春。 &nbsp;&nbsp;&nbsp;&nbsp;我们老了，但青春，依然肆无忌惮。 任尘枫]]></content>
      <categories>
        <category>哟，文艺哦！</category>
      </categories>
      <tags>
        <tag>哟，文艺哦！</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱，只是一个桥段]]></title>
    <url>%2FBlog%2F%E5%93%9F%EF%BC%8C%E6%96%87%E8%89%BA%E5%93%A6%EF%BC%81%2F%E7%88%B1%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A1%A5%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[不经意，目光交汇的瞬间 是最纯的、不含杂质的感情 但这，并不是一见钟情 一见钟情只是因为表面的光彩 偶尔的一个魅惑表情映入眼帘 这时才发现对面的那个人想去了解 试着去接触，试着去喜欢 有的会发现，那个人并不是自己在等的另一半 有的会发现，那人才是自己找的另一半 然后给点勇气来个深情告白 但，相爱不是想的那么简单 爱情有时也会被误解 在我看来真正的爱情根本不存在 经不起时间的考验的爱情 不是爱情，是喜欢 经得起时间的考验的爱情 不是爱情，是亲情 喜欢，爱，血浓于水的亲 爱只是一个桥段 本来就不存在，又何来的未来？ 任尘枫]]></content>
      <categories>
        <category>哟，文艺哦！</category>
      </categories>
      <tags>
        <tag>哟，文艺哦！</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我依然那么贱]]></title>
    <url>%2FBlog%2F%E5%93%9F%EF%BC%8C%E6%96%87%E8%89%BA%E5%93%A6%EF%BC%81%2F%E6%88%91%E4%BE%9D%E7%84%B6%E9%82%A3%E4%B9%88%E8%B4%B1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;年少的无知，童年的幼稚，谁还会一直陪伴着不单纯，不够帅，还一直在犯贱的小孩。拥有了太多的无奈，收藏了许多的悲哀，用我冷冷的外表掩盖。失去一次又一次莫名的爱，懂得了一种又一种不应该的伤害，撇下了一切又一切符合真相的明白。结局在不经意看见，空白一片，只剩下了我这个贱贱的小孩，陪寂寞独自忍耐，看泪花在我的爱中绽开，玩弄着哥特式伤害… &nbsp;&nbsp;&nbsp;&nbsp;没有人会明白，我强忍着的悲哀，犯贱只是为了掩埋，没有人会看见，那一个痛哭的黑夜，搞笑般的以为伤痛可以用泪水洗干。可是一切的一切，没有人会发现，没有人会理解，他们见过的我只是在犯贱，徘徊在人类的界限，挑逗着犯贱的极限。我忍耐，躲在一个人的世界，哭花的脸取代阳光下坏坏的笑脸，陪那说谎的自我聊天。一直在讲，一个人的生活很可爱，却不知’爱’与’哀’无法替代，迷惘的等待，不知谁会撕毁我丢去的读白，撕破我那坏坏的笑脸。后来，我便开始了继续犯贱，犯贱式的想念，犯贱式的等待，犯贱式的伤害，犯贱式的去爱… &nbsp;&nbsp;&nbsp;&nbsp;想要完全放开，那一切不属于我的伤害，可我却发现，我已经习惯了收留伤害，已经习惯了每天坏笑的脸，已经习惯了一个人的世界，已经习惯了犯贱。我现在已经忘却了微笑的表现，不会思索幸福的内涵，不能抓住那浪漫的瞬间。我只能对微笑说再见，对浪漫说抱歉，对于这些感觉我不习惯，这一切我早已经无法去改变，只能丢给怀念，埋葬在岁月的灰尘间，让别人去留恋… &nbsp;&nbsp;&nbsp;&nbsp;从小时到成年，从开始到渐远，从以前到现在，我一直都拥有这一双忧郁的眼，一张掩藏在坏笑下哭花的脸，一颗伤感的心，在我的小小世界里面，演绎着一场场邂逅的偶然，一次次牵手的浪漫，一种种分手的伤感，出现之后又消散，只弥漫了犯贱的路线，我沿着人类的界限，玩着犯贱的极限，一直向前，偶尔回头看看犯贱的反面，走下去，直到永远.. &nbsp;&nbsp;&nbsp;&nbsp;现在，我，依然那么贱。 任尘枫]]></content>
      <categories>
        <category>哟，文艺哦！</category>
      </categories>
      <tags>
        <tag>哟，文艺哦！</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王子遇见公主，那是童话.少年遇见姑娘，才是现实]]></title>
    <url>%2FBlog%2F%E5%93%9F%EF%BC%8C%E6%96%87%E8%89%BA%E5%93%A6%EF%BC%81%2F%E7%8E%8B%E5%AD%90%E9%81%87%E8%A7%81%E5%85%AC%E4%B8%BB%EF%BC%8C%E9%82%A3%E6%98%AF%E7%AB%A5%E8%AF%9D.%E5%B0%91%E5%B9%B4%E9%81%87%E8%A7%81%E5%A7%91%E5%A8%98%EF%BC%8C%E6%89%8D%E6%98%AF%E7%8E%B0%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在人海中我们总会在不经意间和某个素不相识的人目光相撞，却撞不出火花。因为陌生，因为距离，还因为感觉。 &nbsp;&nbsp;&nbsp;&nbsp;我们从儿提到少年，从幼稚到成熟，一路走来，我们遇见了许多人，也失去了许多人。在分分合合的日子里，我们学会了孤独，学会了一个人生活。谁也不会是你的谁，你也不会是谁的谁。 &nbsp;&nbsp;&nbsp;&nbsp;即使有太多的不舍，但一些人毕竟还是应该遗忘的，是应该埋在心底沉淀为秘密的。因为我们不可能回到过去，即使过去再美好，所以我们已经在过去里死去。 &nbsp;&nbsp;&nbsp;&nbsp;那些曾经让我们美到窒息，甜到掉渣的日子，我们知道，但不会再提起。我们之所以会记忆，不单是那美好，还有那悲伤… &nbsp;&nbsp;&nbsp;&nbsp;我们幻想着某天王子会遇见公主，然后爱到天荒地老。 &nbsp;&nbsp;&nbsp;&nbsp;不曾有悲伤，又哪来的成长。 &nbsp;&nbsp;&nbsp;&nbsp;王子遇见公主，那是童话。少年遇见姑娘，才是现实。 &nbsp;&nbsp;&nbsp;&nbsp;只有经历了才会懂，我们只是少年，遇不到公主。我们只是姑娘，等不到王子。 &nbsp;&nbsp;&nbsp;&nbsp;在以后的以后，我们会明白：其实，王子遇见公主，不是最真的童话。少年遇见姑娘，才是最美的现实。 任尘枫]]></content>
      <categories>
        <category>哟，文艺哦！</category>
      </categories>
      <tags>
        <tag>哟，文艺哦！</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等我四年，那时我们结婚]]></title>
    <url>%2FBlog%2F%E5%93%9F%EF%BC%8C%E6%96%87%E8%89%BA%E5%93%A6%EF%BC%81%2F%E7%AD%89%E6%88%91%E5%9B%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E6%97%B6%E6%88%91%E4%BB%AC%E7%BB%93%E5%A9%9A%2F</url>
    <content type="text"><![CDATA[等我四年，那时你若嫁，我若娶，我们结婚。 等我四年，那时你若念我，我若惦你，我们结婚。 等我四年，那时你若看见我，我若找到你，我们结婚。 等我四年，那时你若叫我坏蛋，我若喊你傻瓜，我们结婚。 等我四年，那时你若还对我依赖，我若还对你体贴，我们结婚。 等我四年，那时你若还站在我右边，我若还立在你左边，我们结婚。 等我四年，那时你若能懂得了我的爱，我若依旧拥你入我的怀，我们结婚。 等我四年，那时你若还能感觉到我的温暖，我若还能感受到你的温柔，我们结婚。 等我四年，那时你若不嫌弃我双鬓已经斑白，我若不嫌弃你发丝略微雪白，我们结婚。 等我四年，那时你若不再爱我已成为了他人妻，我若不再爱你已成为他人夫，来世再见。 等你四年，那时你必为我妻。 等我四年，那时我必为你夫。 任尘枫]]></content>
      <categories>
        <category>哟，文艺哦！</category>
      </categories>
      <tags>
        <tag>哟，文艺哦！</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myself度]]></title>
    <url>%2FBlog%2F%E5%93%9F%EF%BC%8C%E6%96%87%E8%89%BA%E5%93%A6%EF%BC%81%2Fmyself%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[浅色的微放如那潜藏的伤 我用深色抒写想逃却岁月沉淀的悲腔 却选择黑色灰白调 又添一抹尚未浅放的悲伤 当寂寞摇晃深藏记忆的楚光 黎明在陪伴着夕阳 是否在地球的某一角 你也会偶尔翻了翻已有味的日记 也会偶尔嘴角微扬 当秋天的第一片枯叶落下 它了却了我一季的牵挂 在酒吧里的喧哗 用酒精混泪添加 苦涩、辛辣融合在一起变化 伤随酒精融进了血液 流进了心房沉淀成家 完结我的一直放不下 现在 可以了 那份温暖 我已不稀罕 走了 剩一个人 温了自己的度 ​ 任尘枫]]></content>
      <categories>
        <category>哟，文艺哦！</category>
      </categories>
      <tags>
        <tag>哟，文艺哦！</tag>
      </tags>
  </entry>
</search>
