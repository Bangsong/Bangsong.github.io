<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搭建属于自己的博客之环境搭建]]></title>
    <url>%2FBlog%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[环境了解 工具： Node npm hexo git 本教程使用的是Hexo + gitHub Pages 搭建的. Hexo：快速生成静态博客的页面. gitHub Pages：充当服务器. Hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 ​ 官方简介：快速、简洁且高效的博客框架。 特点： 速度快 支持markdowm 一键部署 丰富的插件 gitHub​ gitHub是一个面向开源及私有软件项目的托管平台，简单一句：程序员的FaceBook。 环境安装 Node安装​ 首先，在Node官网下载最新版的Node，选择LTS版本，下载好后安装。一般默认安装就好，不会的自行百度安装一下吧。 ​ 安装好之后，Ctrl+R输入cmd启动cmd，执行命令查看版本号(若提示不是内外部命令，则设置一下环境变量)： 1node -v npm安装​ npm是Node的包管理工具，可以自动将所下载的包依赖包一起下载下来。Node已经集成了npm，所以不需要再安装了。 ​ 启动cmd，输入命令查看版本号： 1npm -v Hexo安装​ 所有最好的教程都是官网文档，我们可以去Hexo官网做个入门学习，我下面的介绍一下基本操作。 安装hexo​ 打开cmd，执行命令下载安装hexo 1npm install hexo-cli -g ​ 安装好后，默认安装的目录：C:\Users\Administrator\AppData\Roaming\npm\node_modules\hexo-cli。 初始化博客 创建一个hexo文件夹(可选，不创建也行，我习惯归类，不喜欢将各种东西都放在一起) 打开cmd，移动到该目录下(切换文件夹命令：cd) 创建(不存在则创建)并初始化一个博客文件夹，然后移动到该文件夹下 123hexo init blog #创建并初始化cd blog #移动到blog下npm install #下载所需要的文件 执行启动命令，在浏览器输入：http://localhost:4000 就可以看到页面了。 1hexo server git环境安装​ 在git官网下载git并安装，安装好之后，在cmd中输入命令查看。 1git --version ​ 然后再gitHub上注册一个账号。 创建gitHub Pages 点击头像左侧的+，选择New repository，设置Repository name，格式为：账号名称.github.io(Bangsong.github.io)。Description为项目描述可以不填写，下面选择public(公开项目)，你也只能选public，private是收钱的。 点击Create repository，创建成功。 找到项目的settings，在其中找到Theme Chooser随便选一个主题。 切换到Code界面，点击右侧的Clone or download，查看当前仓库的连接。 接下来就是一系列git的操作了。 目前我git操作不是很懂所以就不再这班门弄斧了，推荐一个教程廖雪峰老师git教程，个人感觉还不错。 结语​ 至此环境就搭建完成了，接下来就是Hexo的主题配置了，又是一段艰辛路…..]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM多数据源注解动态切换]]></title>
    <url>%2FBlog%2Fspring%2FSSM%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%B3%A8%E8%A7%A3%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[创建项目就跳过了，可以查看我之前写的一篇SSM框架搭建 此文章前提是SSM基本配置已经完成，可以连接单数源。 有两种方法，但大致一样，第一种是第一次找到的，但只能在controller层注解，从代码分工来讲，controller不应该处理数据方面的问题，所以第一种方法不推荐，第二种是在service层注解，推荐使用。 方法1第一步：修改db.properties文件 123456789101112131415161718192021222324252627#driver=com.mysql.jdbc.Driverjdbc.driver=com.mysql.cj.jdbc.driverjdbc.url=jdbc:mysql://localhost:3306/jdbc.dbnameDV = dv #数据源1jdbc.dbnameEcharts = echarts #数据源2jdbc.params = useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=root#配置初始化大小、最小、最大initialSize=0maxActive=8minIdle=0maxIdle=8#配置获取连接等待超时的时间maxWait=20000validationQuery=select 1#打开PSCache，并且指定每个连接上PSCache的大小poolPreparedStatements=truemaxPoolPreparedStatementPerConnectionSize=10#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis=60000#配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis=1800000 第二步：配置db.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 加载db.properties文件 --&gt; &lt;context:property-placeholder location="classpath:mybatis/db.properties"/&gt; &lt;!-- 配置数据源，用于访问mysql数据库($&#123;&#125;这种写法称为占位符，具体值在运行时使用db.properties文件中配置的值) com.alibaba.druid.pool.DruidDataSource--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameDV&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;bean id="dataSourceE" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameEcharts&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;!-- 自定义数据源切换类 --&gt; &lt;bean id="dynamicDataSource" class="com.DV.DataSource.DynamicDataSource"&gt; &lt;!-- 这里可以指定默认的数据源 --&gt; &lt;property name="defaultTargetDataSource" ref="dataSource" /&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;!-- 指定lookupKey和与之对应的数据源 --&gt; &lt;entry key="dataSource" value-ref="dataSource"&gt;&lt;/entry&gt; &lt;entry key="dataSourceE" value-ref="dataSourceE"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 上面已经配置了多个数据源，在最下面指定切换数据源的类，以及数据源。 第三步：在spring-mybatis.xml（spring和mybatis整合配置文件）将数据源指定为多数据源切换的id,即：dynamicDataSource。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 该配置文件是mybatis与spring的整合 --&gt; &lt;!-- 整合的固定写法，配置SqlSessionFactory --&gt; &lt;!-- mybatis文件配置，扫描所有mapper.xml文件 --&gt; &lt;!-- 配置mybatisSqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--&lt;property name="dataSource" ref="dataSource" /&gt;&amp;lt;!&amp;ndash; 使用的数据源 &amp;ndash;&amp;gt;--&gt; &lt;property name="dataSource" ref="dynamicDataSource" /&gt;&lt;!-- 使用的数据源 --&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml" /&gt;&lt;!-- mybatis的配置文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/DV/dao/xml/*Mapper.xml" /&gt;&lt;!-- 自动扫描mapper的xml文件 --&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionTemplate --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 为每个Mapper接口在运行时动态生成实现类 --&gt; &lt;!-- 配置mybatis mapper接口，扫描所有dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.DV.dao.mapper" /&gt;&lt;!-- 自动扫描mapper接口，为每个接口生成MapperFactoryBean --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;!-- 如果有多个数据源的话，须指定使用哪一个 --&gt; &lt;/bean&gt;&lt;/beans&gt; 第四步：在事务管理的配置文件中，修改数据源，同上。并加入切面配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 事务配置可以抽象为四部分：数据源、事务管理器、事务属性、事务代理 --&gt; &lt;!-- 数据源：支持事务的数据资源，如数据库 --&gt; &lt;!-- 事务管理器：JDBC事务管理器、EJB容器事务管理器、分布式事务管理器等 --&gt; &lt;!-- 事务属性：事务的传播属性等 --&gt; &lt;!-- 事务代理：将事务属性应用到事务目标对象的方法上，且由事务管理器来管理、如自动的提交或回滚事务 --&gt; &lt;!-- 事务管理 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 对insert,update,delete 开头的方法进行事务管理,只要有异常就回滚 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" rollback-for="java.lang.Throwable"/&gt; &lt;tx:method name="update*" propagation="REQUIRED" rollback-for="java.lang.Throwable"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED" rollback-for="java.lang.Throwable"/&gt; &lt;!-- select,count开头的方法,开启只读,提高数据库访问性能 --&gt; &lt;tx:method name="select*" read-only="true"/&gt; &lt;tx:method name="count*" read-only="true"/&gt; &lt;!-- 对其他方法 使用默认的事务管理 --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id="serviceMethods" expression="execution(* com.DV.service..*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="serviceMethods"/&gt; &lt;/aop:config&gt; &lt;!-- 配置使Spring采用CGLIB代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!-- 对dataSource 数据源进行事务管理 --&gt; &lt;!--&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" p:dataSource-ref="dataSource"/&gt;--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" p:dataSource-ref="dynamicDataSource"/&gt; &lt;!-- 使用annotation注解方式配置事务,启用对事务注解的支持 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.DV.service.impl.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 注意最下面的切面配置 第五步：在spring-mvc(spring和mvc整合配置文件)中，开启aop，对类代理 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:annotation-config /&gt; &lt;!--注解驱动--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;!-- 避免IE执行AJAX时,返回JSON出现下载文件 --&gt; &lt;bean id=&quot;fastJsonHttpMessageConverter&quot; class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 开启aop，对类代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; &lt;bean id=&quot;logAopAction&quot; class=&quot;com.DV.DataSource.LogAopAction&quot;/&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.DV.controller&quot;/&gt; &lt;!--视图解析--&gt; &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; p:prefix=&quot;/WEB-INF/jsp/&quot; p:suffix=&quot;.jsp&quot;/&gt; &lt;!--静态资源--&gt; &lt;mvc:resources mapping=&quot;/content/**&quot; location=&quot;/WEB-INF/content/&quot;/&gt;&lt;/beans&gt; 注意配置中开启aop代码 第六步：创建自定义数据源选择器类DynamicDataSource 123456789101112131415package com.DV.DataSource; import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource; public class DynamicDataSource extends AbstractRoutingDataSource &#123; private static final ThreadLocal&lt;String&gt; dataSourceKey = new InheritableThreadLocal&lt;String&gt;(); public static void setDataSourceKey(String dataSource)&#123; dataSourceKey.set(dataSource); &#125; @Override protected Object determineCurrentLookupKey() &#123; return dataSourceKey.get(); &#125; &#125; 第七步：自定义注解DataSourceChange 123456789101112131415161718package com.DV.DataSource; import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; /** * 定义DataSource的注解 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Documentedpublic @interface DataSourceChange &#123; String dataSource() default "";&#125; 第八步：前置通知（这里切的是controller） 1234567891011121314151617181920212223242526272829303132333435package com.DV.DataSource;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import java.lang.reflect.Method;@Aspectpublic class LogAopAction &#123; //配置接入点 @Pointcut("execution(* com.DV.controller..*.*(..))") private void controllerAspect()&#123;&#125;//定义一个切入点 @Before("controllerAspect()") public void dataSwitch(JoinPoint joinPoint)&#123; Signature signature = joinPoint.getSignature(); MethodSignature methodSignature =(MethodSignature) signature; Method method = methodSignature.getMethod(); DataSourceChange data = null; String dataSource = ""; if(method != null)&#123; data = method.getAnnotation(DataSourceChange.class); if(data != null)&#123; dataSource = data.dataSource(); if(dataSource != null)&#123; DynamicDataSource.setDataSourceKey(dataSource); &#125; &#125; &#125; &#125;&#125; 在conrtoller中的方法上使用：@DataSourceC(dataSource=”数据源ID”)即可，测试代码如下： 1234567@RequestMapping("test")@ResponseBody@DataSourceC(dataSource="dataSourceE")public List test()&#123; List result = dataGraphService.test(); return result;&#125; 测试结果如下： 如图，测试通过，可以注解改变数据源。参考文章地址：https://blog.csdn.net/weixin_38897274/article/details/78529940 方法21、创建接口DataSource，用于定义注解。 123456789101112package com.DV.entity;import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface DataSource &#123; String value();&#125; 2、定义类DynamicDataSource，用于重写AbstractRoutingDataSource以及获取和设置数据源 1234567891011121314151617181920212223package com.DV.entity;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource &#123; public static final ThreadLocal&lt;String&gt; holder = new ThreadLocal&lt;String&gt;(); //设置数据源 public static void setDataSource(String datasource) &#123; holder.set(datasource); &#125; //获取数据源 private String getDataSource() &#123; return holder.get(); &#125; //清除数据源 public static void clearDataSource() &#123; holder.remove(); &#125; @Override protected Object determineCurrentLookupKey() &#123; return getDataSource(); &#125;&#125; 3、定义类DataSourceAspect，用于AOP切面。 12345678910111213141516171819202122232425262728293031323334package com.DV.entity;import java.lang.reflect.Method;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.reflect.MethodSignature;public class DataSourceAspect &#123; //切换数据源 public void before(JoinPoint point) &#123; Object target = point.getTarget(); System.out.println(target.toString()); String method = point.getSignature().getName(); System.out.println(method); Class&lt;?&gt;[] classz = target.getClass().getInterfaces(); Class&lt;?&gt;[] parameterTypes = ((MethodSignature) point.getSignature()) .getMethod().getParameterTypes(); try &#123; Method m = classz[0].getMethod(method, parameterTypes); System.out.println(m.getName()); if (m != null &amp;&amp; m.isAnnotationPresent(DataSource.class)) &#123; DataSource data = m.getAnnotation(DataSource.class); DynamicDataSource.setDataSource(data.value()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //清除数据源，使用默认数据源 public void after()&#123; DynamicDataSource.clearDataSource(); &#125;&#125; 4、最后，还需要修改spring-mvc配置文件。 1234567891011&lt;!-- 开启aop，对类代理 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true" /&gt;&lt;!-- 配置数据库注解aop --&gt;&lt;bean id="dataSourceAspect" class="com.DV.entity.DataSourceAspect" /&gt;&lt;aop:config&gt; &lt;aop:aspect id="c" ref="dataSourceAspect"&gt; &lt;aop:pointcut id="tx" expression="execution(* com.DV.service..*.*(..))"/&gt; &lt;aop:before pointcut-ref="tx" method="before"/&gt; &lt;aop:after pointcut-ref="tx" method="after"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 5、在service方法中使用 12345678910111213141516package com.DV.service;import com.DV.entity.DataSource;import java.util.List;import java.util.Map;public interface dataGraphService &#123; List&lt;Map&gt; echartSet(String corp_id, String type); @DataSource("Echarts") List&lt;Map&gt; test();&#125;---------------------本文来自 XGamerR 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/BangSong/article/details/80775249?utm_source=copy 测试可以切换。 参考文章地址：https://blog.csdn.net/wolfjin/article/details/72465668]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架搭建]]></title>
    <url>%2FBlog%2Fspring%2FSSM%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[第一步：创建maven项目在idea新建项目，选择如下： Maven→勾选Create from archetype→maven-archetype-webapp，然后一直下一步即可创建成功，成功之后会提示是否自动导入包，选择自动导入。 第二步：配置依赖包 在pom.xml文件中配置一系列依赖包。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!-- spring依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-spring依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- datasource依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接器依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签库依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--json解析配置--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.39&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; java目录为Sources root(源文件)，右键将目录标记为 Sources root。放java源码 controller、dao、service分别为：访问控制层、数据持久层、业务逻辑层。util为工具类包。 resources目录为Resources root(资源文件)，右键将目录标记为Resources root。放配置文件 第四步：配置web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" version="2.4"&gt; &lt;!--主配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--字符过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--session保持时间分钟为单位--&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!--监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置和完web.xml之后，里面配置了一些其他的配置文件，接下来逐个配置 配置config.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;import resource="classpath:mybatis/db.xml"/&gt; &lt;import resource="classpath:spring/spring-mybatis.xml"/&gt; &lt;import resource="classpath:spring/spring-tx.xml"/&gt;&lt;/beans&gt; 配置spring-mvc.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:annotation-config /&gt; &lt;!--注解驱动--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;!-- 避免IE执行AJAX时,返回JSON出现下载文件 --&gt; &lt;bean id="fastJsonHttpMessageConverter" class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package="com.dv"/&gt; &lt;!--视图解析--&gt; &lt;bean id="ViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/jsp/" p:suffix=".jsp"/&gt; &lt;!--静态资源--&gt; &lt;mvc:resources mapping="/content/**" location="/WEB-INF/content/"/&gt; &lt;!-- 开启aop，对类代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true" /&gt; &lt;!-- 配置数据库注解aop --&gt; &lt;bean id="dataSourceAspect" class="com.dv.util.DataSourceAspect" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="c" ref="dataSourceAspect"&gt; &lt;aop:pointcut id="tx" expression="execution(* com.dv.service..*.*(..))"/&gt; &lt;aop:before pointcut-ref="tx" method="before"/&gt; &lt;aop:after pointcut-ref="tx" method="after"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 此时，还需要配置config.xml中的配置文件，依次配置： 配置db.properties 123456789101112131415161718192021222324252627#driver=com.mysql.jdbc.Driverjdbc.driver=com.mysql.cj.jdbc.driverjdbc.url=jdbc:mysql://localhost:3306/jdbc.dbnameXSofe = xsofejdbc.dbnameEcharts = echartsjdbc.params = useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=root#配置初始化大小、最小、最大initialSize=0maxActive=8minIdle=0maxIdle=8 #配置获取连接等待超时的时间maxWait=20000validationQuery=select 1 #打开PSCache，并且指定每个连接上PSCache的大小poolPreparedStatements=truemaxPoolPreparedStatementPerConnectionSize=10 #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis=60000 #配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis=1800000 配置db.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 加载db.properties文件 --&gt; &lt;context:property-placeholder location="classpath:mybatis/db.properties"/&gt; &lt;!-- 配置数据源，用于访问mysql数据库($&#123;&#125;这种写法称为占位符，具体值在运行时使用db.properties文件中配置的值) com.alibaba.druid.pool.DruidDataSource--&gt; &lt;bean id="dataSourceXSofe" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameXSofe&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;bean id="dataSourceEcharts" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;$&#123;jdbc.dbnameEcharts&#125;?$&#123;jdbc.params&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt; &lt;!-- 自定义数据源切换类 --&gt; &lt;bean id="DynamicDataSource" class="com.dv.util.DynamicDataSource"&gt; &lt;!-- 这里可以指定默认的数据源 --&gt; &lt;property name="defaultTargetDataSource" ref="dataSourceXSofe" /&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;!-- 指定lookupKey和与之对应的数据源 --&gt; &lt;entry key="DV" value-ref="dataSourceXSofe"&gt;&lt;/entry&gt; &lt;entry key="Echarts" value-ref="dataSourceEcharts"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 配置spring-mybatis.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 该配置文件是mybatis与spring的整合 --&gt; &lt;!-- 整合的固定写法，配置SqlSessionFactory --&gt; &lt;!-- mybatis文件配置，扫描所有mapper.xml文件 --&gt; &lt;!-- 配置mybatisSqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--&lt;property name="dataSource" ref="dataSource" /&gt;&amp;lt;!&amp;ndash; 使用的数据源 &amp;ndash;&amp;gt;--&gt; &lt;property name="dataSource" ref="DynamicDataSource" /&gt;&lt;!-- 使用的数据源 --&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml" /&gt;&lt;!-- mybatis的配置文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/dv/dao/xml/*Mapper.xml" /&gt;&lt;!-- 自动扫描mapper的xml文件 --&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionTemplate --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 为每个Mapper接口在运行时动态生成实现类 --&gt; &lt;!-- 配置mybatis mapper接口，扫描所有dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.dv.dao.mapper" /&gt;&lt;!-- 自动扫描mapper接口，为每个接口生成MapperFactoryBean --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;!-- 如果有多个数据源的话，须指定使用哪一个 --&gt; &lt;/bean&gt;&lt;/beans&gt; 配置spring-tx.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 该配置文件是mybatis与spring的整合 --&gt; &lt;!-- 整合的固定写法，配置SqlSessionFactory --&gt; &lt;!-- mybatis文件配置，扫描所有mapper.xml文件 --&gt; &lt;!-- 配置mybatisSqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--&lt;property name="dataSource" ref="dataSource" /&gt;&amp;lt;!&amp;ndash; 使用的数据源 &amp;ndash;&amp;gt;--&gt; &lt;property name="dataSource" ref="DynamicDataSource" /&gt;&lt;!-- 使用的数据源 --&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml" /&gt;&lt;!-- mybatis的配置文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/dv/dao/xml/*Mapper.xml" /&gt;&lt;!-- 自动扫描mapper的xml文件 --&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionTemplate --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 为每个Mapper接口在运行时动态生成实现类 --&gt; &lt;!-- 配置mybatis mapper接口，扫描所有dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.dv.dao.mapper" /&gt;&lt;!-- 自动扫描mapper接口，为每个接口生成MapperFactoryBean --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;!-- 如果有多个数据源的话，须指定使用哪一个 --&gt; &lt;/bean&gt;&lt;/beans&gt; 配置mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置mybatis的缓存，延迟加载等等一系列属性 --&gt; &lt;settings&gt; &lt;!-- 该配置影响的所有映射器中配置的缓存的全局开关。默认true --&gt; &lt;setting name="cacheEnabled" value="true" /&gt; &lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。默认false --&gt; &lt;setting name="lazyLoadingEnabled" value="true" /&gt; &lt;!-- 是否允许单一语句返回多结果集（需要兼容驱动）。 默认true --&gt; &lt;setting name="multipleResultSetsEnabled" value="true" /&gt; &lt;!-- 使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。默认true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。 默认false --&gt; &lt;setting name="useGeneratedKeys" value="false" /&gt; &lt;!-- 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 默认 PARTIAL --&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING" /&gt; &lt;!-- 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。默认SIMPLE --&gt; &lt;setting name="defaultExecutorType" value="SIMPLE" /&gt; &lt;!-- 设置超时时间，它决定驱动等待数据库响应的秒数。Not Set (null) --&gt; &lt;setting name="defaultStatementTimeout" value="25" /&gt; &lt;!-- 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 --&gt; &lt;setting name="defaultFetchSize" value="100" /&gt; &lt;!-- 允许在嵌套语句中使用分页（RowBounds）。 If allow, set the false. --&gt; &lt;setting name="safeRowBoundsEnabled" value="false" /&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false" /&gt; &lt;!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&gt; &lt;setting name="localCacheScope" value="SESSION" /&gt; &lt;!-- 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 --&gt; &lt;setting name="jdbcTypeForNull" value="OTHER" /&gt; &lt;!-- 指定哪个对象的方法触发一次延迟加载。 --&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString" /&gt; &lt;!-- 打印mybatis中Sql语句--&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt; &lt;!-- mybatis自己的配置文件(mybatis自己单独使用和与spring整合在一起使用这两种情况的配置方式是完全不一样的) --&gt; &lt;!--&lt;typeAliases&gt;--&gt; &lt;!--&lt;package name="org.eop.spring.mvc.mybatis.bean"/&gt;--&gt; &lt;!--&lt;/typeAliases&gt;--&gt;&lt;/configuration&gt; 上述配置中，我配置的是两个数据源，其中通过注解切换。详情见我的另一篇文章：SSM多数据源注解动态切换。 配置完之后的目录： 测试： 创建一个homeController，将项目默认创建的index.jsp文件移动到jsp/home下。 homeController代码： 12345678910111213package com.dv.controller; import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping("/")public class homeController &#123; @RequestMapping public String index()&#123; return "home/index"; &#125;&#125; 然后配置一下tomcat，tomcat自行下载。 测试结果： 至此，SSM框架搭建完成，数据库的测试就不测试了，自行测试吧。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc初识]]></title>
    <url>%2FBlog%2Fspring%2Fspringmvc%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、建立项目打开Idea，选择新建项目。 选择Maven项目，勾选上方的Create from archetype。选择maven-archetype-webapp(若此处不是选的maven则需要自己手动导入所需包) GroupId和Artifactld自己随便填写，最好有意义，然后一直next即可。 二、配置springmvc创建成功之后，如图。点Enable-auto-import 查看文件，找到pom.xml，在此处配置springmvc需要的包，此功能是maven的功能。打开pom.xml，配置所需的依赖包。(此配置代码要放到dependencies标签中) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; 以及bulid 12345678910111213&lt;build&gt; &lt;finalName&gt;springmvcdemo_1&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 至此，只是配置好了所需要的依赖包。配置好之后在外部包处则会看到所配置的依赖包，如图。 接下来就是配置servlet前端控制器。如图中，找到web.xml文件打开进行配置。 配置如下： 主要配置代码： 12345678910111213141516171819&lt;!--servlet前端控制器--&gt; &lt;servlet&gt; &lt;!--前端控制器名字--&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--springmvc其他配置的配置文件(如：处理器映射器、处理器适配器、视图解析器) 若不指定则默认找/WEB-INF/前端控制器名字-servlet.xml --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--路径访问--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置好之后，在resource目录下创建dispathcer-servlet.xml文件，右键此目录，选择XML配置文件，选择spring配置，名字对应的为上面配置中的init-param中的param-value里面的那个文件名。 创建好之后如下： 配置代码如下： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop· http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd "&gt; &lt;!--spring注解驱动器--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--注解适配器--&gt; &lt;context:component-scan base-package="com.rzp.test.controller" /&gt; &lt;!--视图解析器--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 上述配置中的视图解析器中，bean里面的配置分配为解析jsp视图，视图前缀配置，视图后缀配置，在此处配置这些之后在控制器类中返回视图时，则不需要写视图全路径了。不配做则需要返回视图的全路径。配置后了之后，就可以开始写控制器类了。首先在main下创建一个java目录，并将java目录标记为Sources Root，如图： 然后在java目录下创建一个包：包名可以自己随便定，但是此包名要和上述配置中的注解适配器中的base-package的值。创建好之后在其包中创建一个java类，创建好之后在类中写代码，如图： 其中@Controller是将此类标记为一个控制器。至此一个简单的springmvc项目则配置成功。然后配置一下tomcat，点击运行即可查看效果。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lisp的永恒之道]]></title>
    <url>%2FBlog%2FLisp%2FLisp%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[Lisp的永恒之道原文地址：http://www.cnblogs.com/weidagang2046/archive/2012/06/03/tao_of_lisp.html Lisp之魅长久以来，Lisp一直被许多人视为史上最非凡的编程语言。它不仅在50多年前诞生的时候带来了诸多革命性的创新并极大地影响了后来编程语言的发展，即使在一大批现代语言不断涌现的今天，Lisp的诸多特性仍然未被超越。当各式各样的编程语言摆在面前，我们可以从运行效率、学习曲线、社区活跃度、厂商支持等多种不同的角度进行评判和选择，但我特别看中的一点在于语言能否有效地表达编程者的设计思想。学习C意味着学习如何用过程表达设计思想，学习Java意味着学习如何用对象表达设计思想，而虽然Lisp与函数式编程有很大的关系，但学习Lisp绝不仅仅是学习如何用函数表达设计思想。实际上，函数式编程并非Lisp的本质，即使在已经掌握lambda、高阶函数、闭包、惰性求值等函数式编程概念之后，学习Lisp仍然能够大大加深我们对编程的理解。学习Lisp所收获的是如何自由地表达设计思想，这正是Lisp最大的魅力所在，也是这门古老的语言仍然具有很强生命力的根本原因。 Lisp之源Lisp意为列表处理(List Processing)，源自设计者John McCarthy于1960年发表的一篇论文《符号表达式的递归函数及其机器计算》。McCarthy在这篇论文中向我们展示了用一种简单的数据结构S表达式(S-expression)来表示代码和数据，并在此基础上构建一种完整的语言。Lisp语言形式简单、内涵深刻，Paul Graham在《Lisp之根源》中将其对编程的贡献与欧几里德对几何的贡献相提并论。 Lisp之形然而，与数学世界中简单易懂的欧氏几何形成鲜明对比，程序世界中的Lisp却一直是一种古老而又神秘的存在，真正理解其精妙的人还是少数。从表面上看，Lisp最明显的特征是它“古怪”的S表达式语法。S表达式是一个原子(atom)，或者若干S表达式组成的列表(list)，表达式之间用空格分开，放入一对括号中。“列表“这个术语可能会容易让人联想到数据结构中的链表之类的线形结构，实际上，Lisp的列表是一种可嵌套的树形结构。下面是一些S表达式的例子: 123456789foo()(a b (c d) e)(+ (* 2 3) 5)(defun factorial (N) (if (= N 1) 1 (* N (factorial (- N 1))) )) 据说，这个古怪的S表达式是McCarthy在发明Lisp时候所采用的一种临时语法，他实际上是准备为Lisp加上一种被称为M表达式(M-expression)的语法，然后再把M表达式编译为S表达式。用一个通俗的类比，S表达式相当于是JVM的字节码，而M表达式相当于Java语言，但是后来Lisp的使用者都熟悉并喜欢上了直接用S表达式编写程序，并且他们发现S表达式有许多独特的优点，所以M表达式的引入也就被无限期延迟了。 许多Lisp的入门文章都比较强调Lisp的函数式特性，而我认为这是一种误导。作为Lisp的语法基础，Lisp最大的奥秘不在函数式编程，而就在S表达式本身。“S表达式”是程序的一种形，正如“七言”是诗的一种形，“微博”是信息的一种形。人们常认为语法形式不重要，重要的是语言的语义，比如，Java用throw关键字表示“抛出异常”，而Python用raise关键字，二者语法形式不同，但并无语义上的差别。不过，有时候形式的结构特征的确非常重要。唐诗与宋词有着不同的韵味，难道与诗词的形式没有关系？微博和博客都可以作为信息交流的工具，但二者在文化内涵上完全不同，难道也与形式没有关系？语法是语义的载体，形式是实质的寄托，要表达不同的实质，必须有与之配合的形式，因此，Lisp之所以成为非凡的语言，离不开它非凡的语法形式：S表达式。 Lisp之道一门语言能否有效地表达编程者的设计思想取决于其抽象机制的语义表达能力。根据抽象维度的不同，常见的语言抽象机制形成了面向过程、面向对象、函数式、并发式等不同的范式。当我们采用某一种语言，基本上就表示我们已经“面向xxx“了，我们的思维方式和解决问题的手段就会依赖于语言所提供的抽象方式。比如，采用Java语言通常意味着采用面向对象分析设计；采用Erlang通常意味着按Actor模型对并发任务进行建模。 有经验的程序员都知道，无论是面向xxx编程，程序设计都有一条“抽象原则“：what与how解耦，即把语义的声明式表达和实现细节分开，使得程序更容易理解，也更具灵活性。但是，普通语言的问题就在于表达what的手段非常有限，无非是过程、类、接口、函数、Actor等几种语义，这就要求我们在分析建模时必须把领域模型抽象为这些基本语义。但这往往不是许多领域问题最自然的抽象方式，比如，你完全可以在C语言中通过若干函数来做到make file所做的事情，但C代码很难像make file那样声明式地体现出target、depends等语义，它们只会作为实现细节被淹没在一个个的C函数之中。对于自动化构建问题来讲，最自然的抽象应该是像make file一样把target、depends语义作为“一等公民”，这样我们一看make file就知道有哪些target，它们之间有何种依赖关系。也就是说在描述文件依赖关系的能力上make file显然比C语言更加强大。采用面向对象或是函数式等其它范式去实现make file的功能也会遇到同样的困难，这是因为target、depends语义所代表的抽象维度与面向过程、面向对象以及函数式编程的抽象维度是正交的。 用普通语言解决领域问题所遇到的困难背后正是这些语言的“刚性”特征，它要求我们必须以语言的抽象维度去分析和解决问题，虽然有时候这显得不那么自然。这种刚性与我们上一节中谈到的语法和语义之间的关系有着紧密的联系。因为，任何一门编程语言所提供的语法形式都是有限的，而普通语言中语法和语义是紧耦合关系，比如，C语言中printf(“hello %s”, name)符合函数调用语法，它表达了函数调用语义，除此之外别无他义；Java中interface IRunnable { … }符合接口定义语法，它表达了接口定义语义，除此之外别无他义。在语法和语义紧耦合关系下，普通语言所能表达的语义类型也是有限的，不能凭空创造出更多设计之外的语义。 而Lisp与此截然不同，虽然它只提供S表达式这一种语法形式，比普通语言更加精简，但神奇的是Lisp所能表达的语义是无限的！无限？！为什么？这可能吗？我们马上就要揭开Lisp的神秘面纱了。当你看到Lisp的(f a (b c))的时候，你会想到什么？会不会马上联想到函数求值或是宏扩展？就像在C语言里看到gcd(10, 15)马上想到函数调用，或者在Java里看到class A马上想到类定义一样。如果真是这样，这就是你理解Lisp的一道障碍，因为你已经习惯了顺着语言去思考，总是在想这一句话机器怎么解释执行？那一句话又对应语言的哪个特性？理解Lisp要反过来，让语言顺着你，Lisp的(f a (b c))可以是任何语义，完全由你来定，它可以是函数定义、类定义、数据库查询、文件依赖关系，异步任务的执行关系，业务规则 … 下面我准备先通过几个具体的例子逐步展示Lisp的本质。需要说明的是，由于Lisp的S表达式和XML的语法形式都是一种树形结构，在语义表达方面二者并无本质的差别，为了理解方便，下面我暂且用多数人更为熟悉的XML来写代码，请记住我们可以很轻易地把XML代码和Lisp代码相互转换。 首先，我们可以轻易地用XML来定义一个求两个数最大公约数的函数： 12345678910111213141516171819202122232425&lt;func name='gcd' return_type='int'&gt; &lt;params&gt; &lt;a type='int'/&gt; &lt;b type='int'/&gt; &lt;/params&gt; &lt;body&gt; &lt;if&gt; &lt;equals&gt; &lt;a/&gt; &lt;int&gt;0&lt;/int&gt; &lt;/equals&gt; &lt;/if&gt; &lt;then&gt; &lt;return&gt;&lt;b/&gt;&lt;/return&gt; &lt;/then&gt; &lt;else&gt; &lt;return&gt; &lt;gcd&gt; &lt;modulo&gt;&lt;b/&gt;&lt;a/&gt;&lt;/modulo&gt; &lt;a/&gt; &lt;/gcd&gt; &lt;/return&gt; &lt;/else&gt; &lt;/body&gt;&lt;/func&gt; 其次，我们可以用它来定义类： 12345678910111213&lt;class name="Computer"&gt; &lt;field access="private" type="MainBoard" name="main-board" /&gt; &lt;field access="private" type="CPU" name="cpu" /&gt; &lt;field access="private" type="Memory" name="memory" /&gt; &lt;method access="public" return_type="boolean" name="powerOn" /&gt; &lt;params&gt;...&lt;/params&gt; &lt;body&gt;...&lt;/body&gt; &lt;/method&gt; &lt;method access="public" return_type="boolean" name="powerOff" /&gt; &lt;params&gt;...&lt;/params&gt; &lt;body&gt;...&lt;/body&gt; &lt;/method&gt;&lt;/class&gt; 还可以轻易地用它来编写关系查询： 12345678910111213141516&lt;sql&gt; &lt;select&gt; &lt;column name="employees.id" /&gt; &lt;column name="bonus.amount" /&gt; &lt;/select&gt; &lt;from&gt; &lt;table name="employees" /&gt; &lt;table name="bonus" /&gt; &lt;/from&gt; &lt;where&gt; &lt;equals&gt; &lt;column name="employees.id" /&gt; &lt;column name="bonus.employee_id" /&gt; &lt;/equals&gt; &lt;/where&gt;&lt;/sql&gt; 还可以用它来实现类似make file的自动化构建(语法取自ant)： 12345678910111213141516171819&lt;project name=&quot;MyProject&quot; default=&quot;dist&quot; basedir=&quot;.&quot;&gt; &lt;property name=&quot;src&quot; location=&quot;src&quot;/&gt; &lt;property name=&quot;build&quot; location=&quot;build&quot;/&gt; &lt;property name=&quot;dist&quot; location=&quot;dist&quot;/&gt; &lt;target name=&quot;init&quot;&gt; &lt;mkdir dir=&quot;$&#123;build&#125;&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;compile&quot; depends=&quot;init&quot; description=&quot;compile the source &quot; &gt; &lt;javac srcdir=&quot;$&#123;src&#125;&quot; destdir=&quot;$&#123;build&#125;&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;dist&quot; depends=&quot;compile&quot; description=&quot;generate the distribution&quot; &gt; &lt;mkdir dir=&quot;$&#123;dist&#125;/lib&quot;/&gt; &lt;jar jarfile=&quot;$&#123;dist&#125;/lib/MyProject-$&#123;DSTAMP&#125;.jar&quot; basedir=&quot;$&#123;build&#125;&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;clean&quot; description=&quot;clean up&quot; &gt; &lt;delete dir=&quot;$&#123;build&#125;&quot;/&gt; &lt;delete dir=&quot;$&#123;dist&#125;&quot;/&gt; &lt;/target&gt;&lt;/project&gt; 一口气举了这么多个例子，不知道你是否发现了XML和S表达式这类树形语法在语义构造方面有着特别的“柔性”？我们可以轻易地用树形语法构造出函数、变量、条件判断语义，类、属性、方法语义，可以轻易地构造出关系模型的select、where语义，还可以轻易地构造出make的target、depends语义，等等数不清的语义。在普通语言里，你可以定义一个函数、一个类，但你无法为C语言增加匿名函数特性，也没法给Java语言加上RAII语义，甚至连自己创造一个foreach关键字都不行，而自定义语义意味着在Lisp之上你创造了一门语言！不管是面向过程，面向对象，函数式，还是关系模型，在Lisp里统统都变成了一种DSL，而Lisp本身也就成了一种定义语言的语言，即元语言(Meta Language)。 Lisp的柔性与S表达式有着密切的关系。Lisp并不限制你用S表达式表达什么语义，同样的S表达式语法可以表达各种不同领域的语义，这就是语法和语义解耦。在有限的语法规则下，如果说普通语言的刚性源于“语法和语义紧耦合”，那么Lisp的柔性正是源于“语法和语义解耦”！这使得Lisp可以随意地构造各种领域的DSL，而不强制用某一种范式或是领域视角去分析和解决问题。本质上，Lisp编程代表了一种超越了普通编程范式的范式，这就是Lisp之道：面向语言编程(LOP, Language Oriented Programming)。Wikipedia上是这样描述LOP的： Language oriented programming (LOP) is a style of computer programming in which, rather than solving problems in general-purpose programming languages, the programmer creates one or more domain-specific languages for the problem first, and solves the problem in those languages … The concept of Language Oriented Programming takes the approach to capture requirements in the user’s terms, and then to try to create an implementation language as isomorphic as possible to the user’s descriptions, so that the mapping between requirements and implementation is as direct as possible. LOP范式的基本思想是从问题出发，先创建一门描述领域模型的DSL，再用DSL去解决问题，它具有高度的声明性和抽象性。SQL、make file、CSS等DSL都可以被认为是LOP的具体实例，下面我们再通过两个常见的例子来理解LOP的优势。 例1：在股票交易系统中，交易协议定义了若干二进制的消息格式，交易所和客户端需要对消息进行编码和解码。 消息格式是一种抽象的规范，本身不对语言做任何的限制，你可以用C，C++，Java，或者Python。普通的实现方式是按照消息格式规范，在相应的语言中定义消息结构，并编写相应的编解码函数。假设为一个消息定义结构和实现编解码函数的工作量为M，不同消息类型的数量为N，这种方式的工作量大致为MN。也就是说每增加一种消息类型，就需要为该消息定义结构，实现编解码函数，引入bug的可能性当然也和MN成正比。如果仔细观察不难发现，各个消息结构其实是高度类似的，编解码函数也大同小异，但是普通语言却找不到一种抽象机制能表达这种共性，比如，我们无法通过面向对象的方法定义一个基类把消息结构的共性抽象出来，然后让具体的消息去继承它，达到复用的目的。这正是由于普通语言的抽象维度限制所致，在普通语言中，你只能从函数、类、接口等维度对事物进行抽象，而恰好消息格式共性所在的维度与这些抽象维度并不匹配。 其实，不同消息类型的共性在于它们都具有相同的领域语义，比如，“某字段是另一个字段的md5码”就是一种消息格式的领域语义，这种领域语义是OOP的抽象机制无法描述的，但是我们却可以通过DSL直接声明式地描述它。LOP的思路是先创建一门消息定义DSL，比如，类似Google的Protocol Buffer，Android的AIDL。然后，通过DSL编写消息定义文件，直接声明式地描述消息的结构特征，比如，我们可以声明式地描述“某字段是另一个字段的md5码”。我们还需要为DSL开发编译器用于生成C、Java等通用语言的消息定义和编解码函数。 有了消息定义DSL和编译器之后，由于DSL编写消息定义是一种高度声明式的编程方法，每增加一种消息只需要多编写一个消息定义文件而已，工作量几乎可以忽略不计。所有的工作量都集中在DSL的设计和编译器的开发上，工作量是一个常数C，与消息的数量没有关系；质量保证方面也只需要关注编译器这一点，不会因为增加新的消息类型而引入bug。 例2：在图书管理系统中，需要支持在管理界面上对书籍、学生、班级等各种实体进行管理操作。 如果按传统的三层架构，一般需要在后端程序中为每一种实体定义一个类，并定义相应的方法实现CRUD操作，与之相应的，还需要在前端页面中为每一个实体编写相应的管理页面。这些实体类的CRUD操作都是大同小异的，但细节又各不相同，虽然我们很想复用某些共同的设计实现，但OOP所提供的封装、继承、多态等抽象机制不足以有效捕获实体之间的共性，大量的代码还是必须放在子类中来完成。比如，Student和Book实体类的实现非常相似，但是如果要通过OOP的方式去抽象它们的共性，得出的结果多半是Entity这样的大而空的基类，很难起到复用的效果。 其实，不同实体之间的共性还是在于它们具有相同的领域语义，比如：实体具有属性，属性具有类型，属性具有取值范围，属性具有可读取、可编辑等访问属性，实体之间有关联关系等。LOP方法正是直接面向这种领域语义的。采用LOP方法，我们并不需要为每一个实体类单独编写CRUD方法，也不需要单独编写管理页面，只需要定义一种DSL并实现其编译器；然后，用DSL声明式地编写实体描述文件，去描述实体的属性列表，属性的类型、取值范围，属性所支持的操作，属性之间的关系和约束条件等；最后，通过这个实体描述文件自动生成后端的实体类和前端管理页面。采用LOP，不论前后端采用何种技术，Java也好，C#也好，JSP也好，ASP.NET也好，都可以自动生成它们的代码。采用LOP的工作量和质量都集中在DSL的设计和编译器的开发，与实体的数量无关，也就是说，越是庞大的系统，实体类越多越是能体现LOP的优势。 通过上面两个小例子我们可以感受到，LOP是一种面向领域的，高度声明式的编程方式，它的抽象维度与领域模型的维度完全一致。LOP能让程序员从复杂的实现细节中解脱出来，把关注点集中在问题的本质上，从而提高编程的效率和质量。 接下来的问题是如果需要为某领域设计DSL，我们是应该发明一门类似SQL这样的专用DSL呢，还是用XML或S表达式去定义DSL呢？它们各有何优缺点呢？ 我认为采用XML或S表达式定义DSL的优点主要有：1) SQL、make file、CSS等专用DSL都只能面向各自的领域，而一个实际的领域问题通常是跨越多个领域的，有时我们需要将不同领域融合在一起，但是由于普通语言的刚性，多语言融合通常会是一件非常困难的事情，而XML和S表达式语法结构的单一性和“代码及数据”的特点使得跨领域融合毫无障碍。2) 在为DSL开发编译器或解释器的方面，二者难度不同。对XML和S表达式定义的DSL进行语法分析非常简单，相比之下，对SQL这样的专用DSL进行语法分析，虽然可以借助Lex、Yacc、ANTLR等代码生成工具，但总的来讲复杂度还是要明显高一些。 当然，XML和S表达式的优点也正好是其缺点，由于XML和S表达式的语法形式是固定的，不能像专用DSL那样自由地设计语法。所以，一般来讲专用DSL的语法显得更加简洁。换句话说，XML和Lisp其实是在语法和语义间做了一个交换，用语法的限制换来了语义的灵活。 Lisp之器接下来我们继续探讨DSL的解释执行问题。DSL代码的解释执行一般分为3种典型的方式：1) 通过专门的解释器解释执行；2) 编译生成其他语言的代码，再通过其他语言的解释器解释执行(或编译运行)；3) 自解释。比如，第1类的代表是SQL，上一节举的两个例子都属于第2类，而第3类自解释正是Lisp的特色。 为了理解自解释，我们可以先从内部DSL的解释执行说起。内部DSL是指嵌入在宿主语言中的DSL，比如，Google Test单元测试框架定义了一套基于流畅接口(Fluent Interface)的C++单元测试DSL。从语义构造的角度看，内部DSL直接借用宿主语言的语法定义了自己的领域语义，是一种语法和语义解耦；从解释执行的角度看，内部DSL是随宿主语言的解释器而自动解释的，不需要像外部DSL一样开发专门的解释器，因而实现的代价很低。当然，并不是说设计内部DSL不用关心任何的解释实现，实际上，还是需要熟悉宿主语言的特性，并利用该特性使得DSL能随着宿主语言的解释器得到解释执行。 Lisp拥有强大的自解释特性，这得益于独一无二的Lisp之器：宏(macro)。宏使得Lisp编写的DSL可以被Lisp解释器直接解释执行，这在原理上与内部DSL是相通的，只是内部DSL一般是利用宿主语言的链式调用等特性，通常形式简陋，功能有限，而Lisp的宏则要强大和灵活得多。 C语言中也有宏的概念，不过Lisp的宏与C语言的宏完全不同，C语言的宏是简单的字符串替换。比如，下面的宏定义： 1#define square(x) (x*x) square(1+1)的期望结果是4，而实际上它会被替换成(1+1*1+1)，结果是3。这个例子说明，C语言的宏只在预编译阶段进行简单的字符串替换，对程序语法结构缺乏理解，非常脆弱。Lisp的宏不是简单的字符串替换，而是一套完整的代码生成系统，它是在语法解析的基础上把Lisp代码从一种形式转换为另一种形式，本质上起到了普通语言编译器的作用。不同的是，普通编译器是把一种语言的代码转换为另一种语言的代码，比如，Java编译器把Java代码转换成Java字节码；而Lisp宏的输入和输出都是S表达式，它本质上是把一种DSL转换为另一种DSL。下面的例子是宏的一个典型用法。 例3：假设Lisp解释器已经具备解释执行面向过程DSL的能力，需要实现类似ant的自动化构建工具。 我们可以基于宏构建一门类ant的DSL，宏的作用是把类ant DSL通过宏展开变成面向过程的DSL，最后被Lisp解释器所解释执行。这样用Lisp编写的ant DSL就不需要被编译为其他语言，也不需要像XML的ant一样依赖于专门的解释器了。 当然，和开发专门的解释器/编译器相比，Lisp的宏也并非没有缺点，宏难以理解，开发和调试更加困难。到底是开发专门的解释器/编译器还是直接采用宏应该视具体情况而定。 总结Lisp采用单一的S表达式语法表达不同的语义，实现了语法和语义解耦。这使得Lisp具有强大的语义构造能力，擅长于构造DSL实现面向语言编程，而宏使得Lisp具有自解释能力，让不同DSL之间的转换游刃有余。进入Lisp的世界应当从理解面向语言编程入门，这是Lisp之道，而函数式编程和宏皆为Lisp之器，以道驭器方为正途。 后记本文是我学习Lisp的一个总结，也是写给有兴趣学习Lisp的程序员的入门资料。必须说明，我还是一个标准的Lisp初学者，几乎没有写过像样的Lisp程序，文中的错误和不足在所难免，希望读者批评指正，感谢！]]></content>
      <categories>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
      </tags>
  </entry>
</search>
